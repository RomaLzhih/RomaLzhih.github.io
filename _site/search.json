[
  
    {
      "title"       : "Orthogonal Range Searching",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Orthogonal-Range-Search.html",
      "date"        : "2022-11-11 00:48:20 +0000",
      "description" : "Algorithms for Orthogonal Range Searching",
      "content"     : "Definition A query asking to report all records whose fields lie between specified values, then transforms to a query asking for all points inside a $d$-dimensional axis-parallel box. Such a query is called a rectangular range query, or an orthogonal range query in CG.Normalization $x$- and $y$-coordinates of points can be replaced by integers $1,2,3,\\cdots, n$ in $O(n\\log n)$ time (First sort and re-index). When querying, the coordinates of of the rectangle corners can be transformed to appropriate integers in $O(\\log n)$ time.In the remainder of this section we assume that no two pints in $P$ have the same $x$-coordinate, and no two points have the same $y$-coordinate.Kd-TreesBasic DefinitionA Kd-Tree looks like:Every vertical/horizontal line split current graph into two parts each with equal number of points on both sides until each partition contains only one point. Each node in Kd-tree represents a line. The nodes in even length from root represent the vertical line and others on odd length represent the odd line.Preprocessing TimeThe most expensive step is performed at every recursive call is finding the splitting line. This requires determining the median $x$-coordinate or the median $y$-coordinate, depending on whether the depth is even or odd. We find the median in linear time relative simply in such way, sort by $x$- and $y$- coordinates independently. Hence, the building time $T(n)$ satisfies the recurrence:\\(T_n=\\begin{cases}O(1), &amp; if\\quad n=1\\\\O(n)+2T(\\lceil n/2\\rceil), &amp; if \\quad n&gt;1\\end{cases}\\)which solves to $O(n\\log n)$. Here $O(n)$ is the expense for median finding and recursive expression $T(\\lceil n/2\\rceil)$ shows the left and right build procedure.Space: Binary tree with $n$ leaves. $O(n)$ space.Lemma A Kd-tree for a set of $n$ points uses $O(n)$ storage and can be constructed in $O(n\\log n)$ time.Query TimeThe region of a node $v$, denoted as $region(v)$, in Kd-Tree is:Such a $region(v)$ is formed by the line represented by the ancestor nodes of $v$.The query algorithm is: we traverse the Kd-Tree, but visit only nodes whose region is interested by the query rectangle. When a region is fully contained in the query rectangle, we can report all the points stored in its subtree. When the traversal reaches a leaf, we have to check whether the points stored at the leaf is contained in the query region and, if so, report it.The main test of the query algorithm performs is whether the query range $R$ intersects the region corresponding to some node $v$. One can maintain the current region through the recursive calls using the lines stored in the internal nodes. For instance, the region corresponding to the left child of a node $ν$ at even depth can be computed from $region(ν)$ as follows:\\(\\operatorname{region}(l c(v))=\\operatorname{region}(v) \\cap \\ell(v)^{\\text {left }}\\)where $\\ell(v)$ is the splitting line stored at $v$, and $\\ell(v)^{left}$ is the half-plane to the left of and including $\\ell(v)$.The time we need to traverse a subtree and report the points stored in its leaves is linear in the number of reported points, which is $O(k)$. Besides, it remains to bound the number of nodes visited by the query algorithm that are not in one of the traversed subtrees. To analyze the number of such nodes, we shall bound the number of regions interested by any vertical line.Let $\\ell$ be a vertical line, and let $\\mathcal{T}$ be a Kd-Tree. Let $\\ell(root(\\mathcal{T}))$ be the splitting line stored at the root of the Kd-Tree. Observe that if the line $\\ell$ intersects, for instance $region(lc(root(\\mathcal{T})))$, then it will always intersect the regions corresponding to both children of $lc(root(\\mathcal{T}))$.Define $Q(n)$ as the number of interested regions in a Kd-Tree storing $n$ points whose root contains a vertical splitting line. To write recurrence for $Q(n)$ we have to go down two steps in the tree. Each of the four nodes at depth two in the tree corresponds to a region containing $n/4$ points.Two of the four nodes correspond to intersected regions (at least two regions would be interested by such region), so we have to count the number of intersected regions of the remaining 2 nodes ($Q(n/4)+Q(n/4)$) in these subtrees recursively. Hence, $Q(n)$ satisfies the recurrence\\(Q(n)=\\begin{cases}O(1), &amp;if \\quad n=1\\\\2 + 2Q(n/4), &amp;if \\quad n&gt;1\\end{cases}\\)This recurrence solves to $Q(n)=O(\\sqrt{n})$. In other words, any vertical line intersects $O(\\sqrt{n})$ regions in a Kd-Tree.Theorem A Kd-Tree for a set $P$ of $n$ points in the plane use $O(n)$ storage and can be built in $O(n\\log n)$ time. A rectangular range query on the Kd-Tree takes $O(\\sqrt n+k)$ time, where $k$ is the number of reported points. If its $d$-dimensional, the query time is bounded by $O(n^{1-1/d}+k)$.1-Dimensional Range SearchAbove data structure is a BST and we call it Threaded Binary Tree .For a 1-dimensional range query, $[u,u’]$, we first binary search $u$ in the tree, for each node $v$, report nodes in $rc(v)$ . Then search $u’$ and report all nodes in $lc(v)$.Theorem Let $P$ be a set of $n$ points in 1-dimensional space. The set $P$ can be stored in a balanced BST, which uses $O(n)$ storage and has $O(n\\log n)$ construction time, such that the points in a query range can be reported in time $O(k+\\log n)$, where $k$ is the number of reported points.Range TreeThe range tree is: The main tree $\\mathcal{T}$ is a balanced binary search tree built on the $x$-coordinate of the points in $P$. For any internal or leaf node $v\\in \\mathcal{T}$, the canonical subset $P(v)$, which is the subset of points store in the leaves of the subtree rooted at a node $v$, is stored in a balanced BST $\\mathcal{T}{assoc}(v)$ on the $y$-coordinate of the points. The node $v$ stores a pointer to the root of $\\mathcal{T}{assoc}(v)$, which is called the associated structure of $v$.Space Because 1-dimensional range trees use linear storage it follows that the associated structures of all nodes at any depth of $\\mathcal{T}$ together use $O(n)$ storage. The depth of $\\mathcal{T}$ is $O(\\log n)$. Hence, the total amount of storage required is bounded by $O(n\\log n)$.Preconstruct Constructing a BST from an unordered list is $O(n\\log n)$ but if the list is sorted, it could be reduced to $O(n)$. Thus, for this two level structure, we first sort the $x$-coordinate and $y$-coordinate and then we build the first level-tree and second level tree in $O(n)$, totally $O(n\\log n)$.Query First selects $O(\\log n)$ canonical subsets that together contain the points whose $x$-coordinate lie in the range $[x,x’]$, This can be done with the 1-dimensional query algorithm. Of those subsets, we then report the points whose $y$-coordinate lie in the range $[y,y’]$ using same methods. Thus in total $O(\\log^2n+k)$.Theorem Let $P$ be a set of $n$ points in the $d$-dimension. A range tree for $P$ uses $O(n(\\log n)^{d-1})$ storage and can be constructed in $O(n(\\log n)^{d-1})$ time. By querying this range tree one can report the points in $P$ that lie in a rectangular query range in $O(\\log^dn+k)$ time, where $k$ is the number of reported points.Improved Range TreeFractional Cascading​ Let $S_1$ and $S_2$ be two sorted lists of numbers. Generally, if we want to report all objects in $S_1$ and $S_2$ whose keys lie in a query interval $[y,y’]$, we need to do two binary searches with $y$ in $S$ and and walk along $S$ until $y’$. The total time is $O(k)$ plus the time for two binary searches, one in $S_1$ and the other in $S_2$.​ If, however, the keys of the objects in $S_2$ are a subset of the keys of the objects in $S_1$, then we can avoid the second binary search as follows. We add pointers from the entries in $S_1$ to the entries in $S_2$: if $S_1[i]$ stores an object with key $y_i$, then we store a pointer to the entry in $S_2$ with the smallest key larger than or equal to $y_i$. If there is no such key, then the pointer from $S_1[i]$ is $nil$. Then in the search of $S_2$, we just follow the pointer created in process of $S_1$, which takes only $O(1+k)$ time.Range Tree has exactly such structure. We use Fractional Cascading to improve it.After sorted in preprocessing, The second-level structure is always the subset of its ancestor nodes. Since we find the same nodes, in the first level binary search we can position the node we should start search in second level. For example, in root node, we find 2 as the left most point, and the pointer in 2 points to 6 since we have sorted it in $y$-monotone already.Theorem Let $P$ be a set of $n$ points in $d$-dimensional space, with $d\\geq 2$. A layered range tree for $P$ uses $O(n\\log^{d-1}n)$ storage and it can be constructed in $O(n\\log^{d-1}n)$ time. With this range tree one can report the points in $P$ lie in a rectangular query range in $O(\\log^{d-1}n+k)$ time, where $k$ is the number of reported points.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Polygon Triangulation",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Polygon-Triangulation.html",
      "date"        : "2022-11-10 02:48:20 +0000",
      "description" : "Algorithms for polygon triangulation",
      "content"     : "Triangulating a polygonArt gallery problemTwo points in a simple polygon can see each other if their connecting line segment is in the polygon.Definition The art gallery problem:​ How many points are needed in a simple polygon with $n$ vertices so that every point in the polygon is seen?This problem is NP-hard.Theorem art gallery theorem:​ $\\lfloor n/3\\rfloor$ cameras are occasionally necessary but always sufficient.Some Definition Polygon $P$ is triangulated: a decomposition of $P$ into disjoint triangles by a maximal set of non-intersecting diagonals. Diagonal of $P$: open line segment that connects two vertices of $P$ and fully lies in the interior of $P$. Dual graph for a plane graph $G$ is a graph which is, each face in primal graph gives a node; two nodes are connected in dual graph if the faces are adjacent. The dual graph of a triangulated simple polygon without hole is a tree. A simple polygon is y-monotone iff any horizontal line intersects it in a connected set (or not at all), or equivalently, if every horizontal line intersects it at most twice.Lemma: A simple polygon with $n$ vertices can always be triangulated, and always with $n-2$ triangles.Proof Every tree has a leaf, in particular the one that is the dual graph. Remove the corresponding triangle from the triangulated polygon, colour its vertices, add the triangle back, and let the extra vertex have the colour different from its neighbours.For a 3-coloured, triangulated simple, one of the color classes is used by at most $\\lfloor n/3\\rfloor$ colors. Place the cameras at these vertices.Triangulate a polygonOverview: Use plane sweep to partition the polygon into $y$-monotone polygons. Triangulate each $y$-monotone polygon.Partition into monotone piecesVertex type: Start, above space of the vertex does not belongs to the polygon, Stop/End, below space of the vertex does not belongs to the polygon, Split, the polygon separate into two parts after this point, Merge, the polygon merge into one part after this point, Regular.The sweep idea is, find diagonals from each merge vertex down, and from each split vertex up. Since these two kinds of points change the monotone of the polygon.Definition The helper for an edge $e$ that has the polygon right of it, and a position of the sweep line, is the lowest vertex $v$ above the sweep line such that the horizontal line segment connecting $e$ and $v$ is inside the polygon.Definition The status is the set of edges intersecting the sweep line that have the polygon to their right, sorted from left to right, and each with their helper: the last vertex passed in that component. The status structure stores all edges that have the polygon to the right, with their helper, sorted from left to right in the leaves of a balanced binary search tree $T$.The event happen only at the vertices: sort them by $y$-coordinate and put them in a list.Now we begin sweep the initial polygon and prepare to handle the different event when the sweep line meets the vertex of: Start vertex $v$: insert the ccw incident edge in $T$ with $v$ as the helper (the left edge behind $v$). End vertex $v$: delete the clockwise incident edge and its helper from $T$ (the left edge above $v$). Regular vertex $v$: if the polygon is right of the two incident edges, then replace the upper edge by the lower edge in $T$, and make $v$ the helper. If the polygon is left of the two incident edges, then find the edge $e$ directly left of $v$, and replace its helper by $v$. Merge vertex $v$: Remove the edge clockwise from $v$ from $T$. Find the edge $e$ directly left of $v$, and replace its helper by $v$. Split vertex $v$: Find the edge $e$ directly left of $v$, and choose as a diagonal the edge between its helper and $v$. Replace the helper of $e$ by $v$. Insert the edge ccw from $v$ in $T$, with $v$ as its helper.Efficiency:​ Sorting all events by $y$-coordinate takes $O(n\\log n)$ time. Every event takes $O(\\log n)$ time, because it only involves querying, inserting and deleting in $T$.Two-direction Sweep:​ We need to sweep in both upward and downward direction, since unidirectional sweep is insufficient divide the polygon into monotone spices. For a same vertex, maximum 2 diagonals would be chosen to the same vertex. Because, if $u$ is a split vertex, an edge is added to $u$ and the helper of $u$; then the sweep continuous, another split vertex below which regards $u$ as its helper would also add one edge to $u$, then $u$ would never become helper.Theorem: A simple polygon with $n$ vertices can be partitioned into $y$-monotone pieces in $O(n\\log n)$ time.Triangulating a monotone polygonThe algorithm: Sort the vertices top-to-bottom by a merge of the two chains, Initialize a stack. Push the first two vertices, Take the next vertex $v$, and triangulate as much as possible, top-down, while popping the stack, Push $v$ onto the stack.Theorem A monotone polygon with $n$ vertices can be triangulated $O(n)$ time.Triangulating a simple polygonWe need to argue that all $y$-monotone polygons together that we will triangulate have $O(n)$ vertices. Initially we had $n$ edges. We add at most $n-3$ diagonals in the sweeps. These diagonals are used on both sides as edges. So all monotone polygons together have at most $n+2(n-3)=3n-6$ edges, and therefore at most $3n-6$ vertices. Note that the complexity all about the total computation load, hence we can conclude that triangulating all monotone polygons together takes only $O(n)$ time.Theorem A simple polygon with $n$ vertices can be triangulated $O(n\\log n)$ time.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Convex Hull",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Convex-Hull.html",
      "date"        : "2022-11-09 04:48:20 +0000",
      "description" : "Algorithms for computing a Convex Hull",
      "content"     : "Problem DefinitionGiven: A set $Z$ of $n$ points in the plane.Find: Smallest convex set containing $Z$.Some Basic Definition A set $S$ in the plane is convex iff for every pair of points $p_1$ and $p_2$ in $S$, the line-segment $p_1p_2 $ is in $S$. A point $p$ in a convex set $S$ is said to be extreme (or a corner) iff no segment $ab$ in $S$ has $p$ in its interior. $CH(Z)$ is considered to be determined once its corners ordered around the boundary are found. Simplifying assumptions: No pair of Z-points has the same x- or y-coordinate and/or no three points colinear.Equivalent Formulations for CH Intersection of all convex sets containing $Z$. Intersection of all half-planes containing $Z$. Smallest possible convex set containing $Z$. Convex set with the smallest possible perimeter and containing $Z$.Sorting can be transformed in $O(n)$ time into the convex hull problem. Thus the lower bound of the complexity of CH is same as sorting which is $O(n\\log n)$.Point $p_1,p_2,p_3$ make a right turn at $p_2$ iff $p_3$ is to the right or on the line through $p_1$ and $p_2$. Otherwise $p_1,p_2,p_3$ make a left turn at $p_2$. Mathematically speaking, if:\\(det\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\\\x_3 &amp; y_3 &amp; 1\\end{bmatrix}&gt;0 \\Rightarrow \\textit{left turn}\\)Algorithm 1: Point PruningSince: A point in set $Z$ which is not a corner is inside a triangle on $Z$. Use $O(n^3)$ time to enumerate the triangles and for every triangles use $O(n)$ transverse other point to check whether it is contained. When whole procedure finishes, the remaining points never included are corners. Actually, we can select the left/up and right/down extreme points to form a bottom edge for triangle and enumerate the third vertex and check the other $Z$-point inclusion in $O(n\\cdot n)$, cuz that the two extreme points must be included in corners. Then, we need to sort the corners. Take any point in $CH(Z)$ and sort corners around it. Draw line through the leftmost and rightmost corners. Sort corners above the line by increasing x-coordinate and sort corners below the line by decreasing x-coordinate. All this can be done in $O(n\\log n)$ time. Algorithm 2: Edge Pruning → Jarvis March (1973)Naïve approach: Arbitrarily pick one edge $O(n^2)$ and check whether all other points are located on same side of edge (left/right turn, $O(n)$ ). In total $O(n^3)$. Sorting of corners remains.Jarvis’s March: When a boundary edge $z_iz_j$ has been identified, there must exist another boundary edge with $z_j$ as one of its endpoints. Boundary edge can be founded by starting from extreme point. Find boundary edge consecutively. Corner sorting still needed. $O(nh)$, where $h$ is the number of corners. Expected number of corners of points independently and uniformly distributed within a unit circle is $O(n^{1/3})$.Algorithm 3: Graham’s Scan (1972)Procedure: Sort points around some point of CH(Z). Points at the same angle are sorted by their distance. Construct the polygon defined by the sorting. Prune the nodes. If we transverse the nodes in counterclockwise (ccw) order, all middle nodes should make a left turn for pairs $p+,p,p-$, otherwise it can be removed. After remove the middle point $p$, $p-$ would go backward, otherwise all three points walk forward. Algorithm terminate when the initial corner arrived by a forward step.Something may goes wrong: Will never go backwards behind the initial corner, which means if we select a wrong initial corner at first, it would be dropped and we will never trace back to it.Complexity: # of backward steps is $O(n)$. # of forward step is $O(n)$. Sorting $O(n\\log n)$. Totally, $O(n\\log n)$.Algorithm 4: Divide and ConquerPartition $Z$ into balanced subsets $Z_1$ and $Z_2$, determine $CH(Z_1)$ and $CH(Z_2)$ recursively. The problem solve directly if $n\\leq 2$.Merge: For each merge phase, two sub-polygon with corners sorted are available. Then select one point arbitrarily, say point 1. Build two sorted edge set between point 1 and other points. If point 1 is inside another polygon, cause this two edges are all sorted, we can merge them directly. If point 2 is outside another polygon, we pick two extreme points (which is exterior most to point 2), say point 3 and point 4. For all other points $q$, we check whether it make a left turn from point 3 to point 2, or form a right turn from point 4 to point 2. If not, we drop this point. (or we can check whether this point is included by the other polygon)Partition and union complexity:\\(\\begin{array}{c}T(n)=O(1), n \\leq 2 \\\\T(n)=2 * T(n / 2)+O(n), n&gt;2\\end{array}\\)Overall $O(n\\log n)$.Algorithm 5: Marriage-before-Conquest (1986)“Reverse Order” than Divide-and-Conquer.Calculate the Upper and Lower Convex Hulls separately and merge them. Divide the nodes into 2 points, which is approximately same. Find the Bridge across two sides. Drop the nodes exactly below the bridge and compute the left upper CH and right upper CH recursively. Merge.How to find a Bridge? Build edges by pairing two nodes arbitrarily. Select the edge $e$ with median slope. Move $e$ parallelly to the upper/lower extreme point $p$ (no more higher /lower nodes exists). If exactly two nodes from both sides located in same line, the line is bridge and then be returned. Otherwise, for all of other points $p_i$ in same side of $p$, calculate the slope $e_i=(p,p_i)$ . If $p$ is on left side and $e_i&gt;e$, drop $p_i$, or if $p$ is on right side and $e_i&lt;e$, drop $p_i$. Repeat until only 1 node in opposite side of $p$ exists.Complexity containing both Bridge Finding, and Overall Complexity is shown as follows, big constant.Algorithm 6: Chan’sAlgorithms with complexity measured as a function of both $n$ and output size $h$ are said to be output-sensitive.Let $P\\subset E^2$ be a set of $n\\geq 3$ points. The procedure of Chan’s algorithm is:Algorithm Hull2D($P, m, H$), where $P \\subset E^2$, $3 ≤ m ≤ n$, and $H ≥ 1$ partition $P$ into subsets $P_1,\\cdots,P_{\\lceil n/m\\rceil}$ each of size at most $m$ for $i=1,\\cdots, \\lceil n/m\\rceil$ do compute conv($P_i$) by Graham’s scan and store its vertices in an array in ccw order $p_0\\leftarrow (0,-\\infty)$ $p_1\\leftarrow$ the rightmost point of $P$ for $k=1,\\cdots,H$ do for $i=1,\\cdots,\\lceil n/m\\rceil$ do compute the points $q_i\\in P_i$ that maximizes $\\angle p_{k-1}p_kq_i\\quad (q_i\\neq p_k)$ by performing a binary search on the vertices of conv($P_i$) $p_{k+1}\\rightarrow$ the point $q$ from ${q_1,\\cdots,q_{\\lceil n/m\\rceil}}$ that maximizes $\\angle p_{k-1}p_kq$ if $p_{k+1}=p_1$ then return the list $\\langle p_1,\\cdots,p_k\\rangle$ return incompleteBy choosing $m = H$, the complexity of the algorithm is then $O(n(1+H/m) \\log m) = O(n \\log H)$. Since the value of $h$ is not known in advance, we use a sequence of $H$’s to “guess” its value as shown below:Algorithm Hull2D($P$), where $P \\subset E^2$ for $t = 1, 2,\\cdots $ do $L\\rightarrow $ Hull2D($P,m,H$), where $m=H=\\min{2^{2^t},n}$ if $L\\neq incomplete$ then return $L$ The procedure stops with the list of hull vertices as soon as the value of $H$ in the for-loop reaches or exceeds $h$. The number of iterations in the loop is $\\lceil \\log \\log h\\rceil$ (using base-2 logarithms), and the $t$-th iteration takes $O(n \\log H) = O(n2^t )$ time. Therefore, the total running time of the algorithm is $O(\\sum_{t=1}^{\\lceil \\log\\log h\\rceil}n2^t)=O(n2^{\\lceil\\log\\log h\\rceil+1})=O(n\\log h)$. The storage requirement is clearly linear.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } 
  
]
