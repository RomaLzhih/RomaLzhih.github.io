[
  
    {
      "title"       : "Polygon Triangulation",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Polygon-Triangulation.html",
      "date"        : "2022-11-10 02:48:20 +0000",
      "description" : "Algorithms for polygon triangulation",
      "content"     : "Triangulating a polygonArt gallery problemTwo points in a simple polygon can see each other if their connecting line segment is in the polygon.Definition The art gallery problem:​ How many points are needed in a simple polygon with $n$ vertices so that every point in the polygon is seen?This problem is NP-hard.Theorem art gallery theorem:​ $\\lfloor n/3\\rfloor$ cameras are occasionally necessary but always sufficient.Some Definition Polygon $P$ is triangulated: a decomposition of $P$ into disjoint triangles by a maximal set of non-intersecting diagonals. Diagonal of $P$: open line segment that connects two vertices of $P$ and fully lies in the interior of $P$. Dual graph for a plane graph $G$ is a graph which is, each face in primal graph gives a node; two nodes are connected in dual graph if the faces are adjacent. The dual graph of a triangulated simple polygon without hole is a tree. A simple polygon is y-monotone iff any horizontal line intersects it in a connected set (or not at all), or equivalently, if every horizontal line intersects it at most twice.Lemma: A simple polygon with $n$ vertices can always be triangulated, and always with $n-2$ triangles.Proof Every tree has a leaf, in particular the one that is the dual graph. Remove the corresponding triangle from the triangulated polygon, colour its vertices, add the triangle back, and let the extra vertex have the colour different from its neighbours.For a 3-coloured, triangulated simple, one of the color classes is used by at most $\\lfloor n/3\\rfloor$ colors. Place the cameras at these vertices.Triangulate a polygonOverview: Use plane sweep to partition the polygon into $y$-monotone polygons. Triangulate each $y$-monotone polygon.Partition into monotone piecesVertex type: Start, above space of the vertex does not belongs to the polygon, Stop/End, below space of the vertex does not belongs to the polygon, Split, the polygon separate into two parts after this point, Merge, the polygon merge into one part after this point, Regular.The sweep idea is, find diagonals from each merge vertex down, and from each split vertex up. Since these two kinds of points change the monotone of the polygon.Definition The helper for an edge $e$ that has the polygon right of it, and a position of the sweep line, is the lowest vertex $v$ above the sweep line such that the horizontal line segment connecting $e$ and $v$ is inside the polygon.Definition The status is the set of edges intersecting the sweep line that have the polygon to their right, sorted from left to right, and each with their helper: the last vertex passed in that component. The status structure stores all edges that have the polygon to the right, with their helper, sorted from left to right in the leaves of a balanced binary search tree $T$.The event happen only at the vertices: sort them by $y$-coordinate and put them in a list.Now we begin sweep the initial polygon and prepare to handle the different event when the sweep line meets the vertex of: Start vertex $v$: insert the ccw incident edge in $T$ with $v$ as the helper (the left edge behind $v$). End vertex $v$: delete the clockwise incident edge and its helper from $T$ (the left edge above $v$). Regular vertex $v$: if the polygon is right of the two incident edges, then replace the upper edge by the lower edge in $T$, and make $v$ the helper. If the polygon is left of the two incident edges, then find the edge $e$ directly left of $v$, and replace its helper by $v$. Merge vertex $v$: Remove the edge clockwise from $v$ from $T$. Find the edge $e$ directly left of $v$, and replace its helper by $v$. Split vertex $v$: Find the edge $e$ directly left of $v$, and choose as a diagonal the edge between its helper and $v$. Replace the helper of $e$ by $v$. Insert the edge ccw from $v$ in $T$, with $v$ as its helper.Efficiency:​ Sorting all events by $y$-coordinate takes $O(n\\log n)$ time. Every event takes $O(\\log n)$ time, because it only involves querying, inserting and deleting in $T$.Two-direction Sweep:​ We need to sweep in both upward and downward direction, since unidirectional sweep is insufficient divide the polygon into monotone spices. For a same vertex, maximum 2 diagonals would be chosen to the same vertex. Because, if $u$ is a split vertex, an edge is added to $u$ and the helper of $u$; then the sweep continuous, another split vertex below which regards $u$ as its helper would also add one edge to $u$, then $u$ would never become helper.Theorem: A simple polygon with $n$ vertices can be partitioned into $y$-monotone pieces in $O(n\\log n)$ time.Triangulating a monotone polygonThe algorithm: Sort the vertices top-to-bottom by a merge of the two chains, Initialize a stack. Push the first two vertices, Take the next vertex $v$, and triangulate as much as possible, top-down, while popping the stack, Push $v$ onto the stack.Theorem A monotone polygon with $n$ vertices can be triangulated $O(n)$ time.Triangulating a simple polygonWe need to argue that all $y$-monotone polygons together that we will triangulate have $O(n)$ vertices. Initially we had $n$ edges. We add at most $n-3$ diagonals in the sweeps. These diagonals are used on both sides as edges. So all monotone polygons together have at most $n+2(n-3)=3n-6$ edges, and therefore at most $3n-6$ vertices. Note that the complexity all about the total computation load, hence we can conclude that triangulating all monotone polygons together takes only $O(n)$ time.Theorem A simple polygon with $n$ vertices can be triangulated $O(n\\log n)$ time."
    } ,
  
    {
      "title"       : "Convex Hull",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Convex-Hull.html",
      "date"        : "2022-11-09 04:48:20 +0000",
      "description" : "Algorithms for computing a Convex Hull",
      "content"     : "Problem DefinitionGiven: A set $Z$ of $n$ points in the plane.Find: Smallest convex set containing $Z$.Some Basic Definition A set $S$ in the plane is convex iff for every pair of points $p_1$ and $p_2$ in $S$, the line-segment $p_1p_2 $ is in $S$. A point $p$ in a convex set $S$ is said to be extreme (or a corner) iff no segment $ab$ in $S$ has $p$ in its interior. $CH(Z)$ is considered to be determined once its corners ordered around the boundary are found. Simplifying assumptions: No pair of Z-points has the same x- or y-coordinate and/or no three points colinear.Equivalent Formulations for CH Intersection of all convex sets containing $Z$. Intersection of all half-planes containing $Z$. Smallest possible convex set containing $Z$. Convex set with the smallest possible perimeter and containing $Z$.Sorting can be transformed in $O(n)$ time into the convex hull problem. Thus the lower bound of the complexity of CH is same as sorting which is $O(n\\log n)$.Point $p_1,p_2,p_3$ make a right turn at $p_2$ iff $p_3$ is to the right or on the line through $p_1$ and $p_2$. Otherwise $p_1,p_2,p_3$ make a left turn at $p_2$. Mathematically speaking, if:\\(det\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\\\x_3 &amp; y_3 &amp; 1\\end{bmatrix}&gt;0 \\Rightarrow \\textit{left turn}\\)Algorithm 1: Point PruningSince: A point in set $Z$ which is not a corner is inside a triangle on $Z$. Use $O(n^3)$ time to enumerate the triangles and for every triangles use $O(n)$ transverse other point to check whether it is contained. When whole procedure finishes, the remaining points never included are corners. Actually, we can select the left/up and right/down extreme points to form a bottom edge for triangle and enumerate the third vertex and check the other $Z$-point inclusion in $O(n\\cdot n)$, cuz that the two extreme points must be included in corners. Then, we need to sort the corners. Take any point in $CH(Z)$ and sort corners around it. Draw line through the leftmost and rightmost corners. Sort corners above the line by increasing x-coordinate and sort corners below the line by decreasing x-coordinate. All this can be done in $O(n\\log n)$ time. Algorithm 2: Edge Pruning → Jarvis March (1973)Naïve approach: Arbitrarily pick one edge $O(n^2)$ and check whether all other points are located on same side of edge (left/right turn, $O(n)$ ). In total $O(n^3)$. Sorting of corners remains.Jarvis’s March: When a boundary edge $z_iz_j$ has been identified, there must exist another boundary edge with $z_j$ as one of its endpoints. Boundary edge can be founded by starting from extreme point. Find boundary edge consecutively. Corner sorting still needed. $O(nh)$, where $h$ is the number of corners. Expected number of corners of points independently and uniformly distributed within a unit circle is $O(n^{1/3})$.Algorithm 3: Graham’s Scan (1972)Procedure: Sort points around some point of CH(Z). Points at the same angle are sorted by their distance. Construct the polygon defined by the sorting. Prune the nodes. If we transverse the nodes in counterclockwise (ccw) order, all middle nodes should make a left turn for pairs $p+,p,p-$, otherwise it can be removed. After remove the middle point $p$, $p-$ would go backward, otherwise all three points walk forward. Algorithm terminate when the initial corner arrived by a forward step.Something may goes wrong: Will never go backwards behind the initial corner, which means if we select a wrong initial corner at first, it would be dropped and we will never trace back to it.Complexity: # of backward steps is $O(n)$. # of forward step is $O(n)$. Sorting $O(n\\log n)$. Totally, $O(n\\log n)$.Algorithm 4: Divide and ConquerPartition $Z$ into balanced subsets $Z_1$ and $Z_2$, determine $CH(Z_1)$ and $CH(Z_2)$ recursively. The problem solve directly if $n\\leq 2$.Merge: For each merge phase, two sub-polygon with corners sorted are available. Then select one point arbitrarily, say point 1. Build two sorted edge set between point 1 and other points. If point 1 is inside another polygon, cause this two edges are all sorted, we can merge them directly. If point 2 is outside another polygon, we pick two extreme points (which is exterior most to point 2), say point 3 and point 4. For all other points $q$, we check whether it make a left turn from point 3 to point 2, or form a right turn from point 4 to point 2. If not, we drop this point. (or we can check whether this point is included by the other polygon)Partition and union complexity:\\(\\begin{array}{c}T(n)=O(1), n \\leq 2 \\\\T(n)=2 * T(n / 2)+O(n), n&gt;2\\end{array}\\)Overall $O(n\\log n)$.Algorithm 5: Marriage-before-Conquest (1986)“Reverse Order” than Divide-and-Conquer.Calculate the Upper and Lower Convex Hulls separately and merge them. Divide the nodes into 2 points, which is approximately same. Find the Bridge across two sides. Drop the nodes exactly below the bridge and compute the left upper CH and right upper CH recursively. Merge.How to find a Bridge? Build edges by pairing two nodes arbitrarily. Select the edge $e$ with median slope. Move $e$ parallelly to the upper/lower extreme point $p$ (no more higher /lower nodes exists). If exactly two nodes from both sides located in same line, the line is bridge and then be returned. Otherwise, for all of other points $p_i$ in same side of $p$, calculate the slope $e_i=(p,p_i)$ . If $p$ is on left side and $e_i&gt;e$, drop $p_i$, or if $p$ is on right side and $e_i&lt;e$, drop $p_i$. Repeat until only 1 node in opposite side of $p$ exists.Complexity containing both Bridge Finding, and Overall Complexity is shown as follows, big constant.Algorithm 6: Chan’sAlgorithms with complexity measured as a function of both $n$ and output size $h$ are said to be output-sensitive.Let $P\\subset E^2$ be a set of $n\\geq 3$ points. The procedure of Chan’s algorithm is:Algorithm Hull2D($P, m, H$), where $P \\subset E^2$, $3 ≤ m ≤ n$, and $H ≥ 1$ partition $P$ into subsets $P_1,\\cdots,P_{\\lceil n/m\\rceil}$ each of size at most $m$ for $i=1,\\cdots, \\lceil n/m\\rceil$ do compute conv($P_i$) by Graham’s scan and store its vertices in an array in ccw order $p_0\\leftarrow (0,-\\infty)$ $p_1\\leftarrow$ the rightmost point of $P$ for $k=1,\\cdots,H$ do for $i=1,\\cdots,\\lceil n/m\\rceil$ do compute the points $q_i\\in P_i$ that maximizes $\\angle p_{k-1}p_kq_i\\quad (q_i\\neq p_k)$ by performing a binary search on the vertices of conv($P_i$) $p_{k+1}\\rightarrow$ the point $q$ from ${q_1,\\cdots,q_{\\lceil n/m\\rceil}}$ that maximizes $\\angle p_{k-1}p_kq$ if $p_{k+1}=p_1$ then return the list $\\langle p_1,\\cdots,p_k\\rangle$ return incompleteBy choosing $m = H$, the complexity of the algorithm is then $O(n(1+H/m) \\log m) = O(n \\log H)$. Since the value of $h$ is not known in advance, we use a sequence of $H$’s to “guess” its value as shown below:Algorithm Hull2D($P$), where $P \\subset E^2$ for $t = 1, 2,\\cdots $ do $L\\rightarrow $ Hull2D($P,m,H$), where $m=H=\\min{2^{2^t},n}$ if $L\\neq incomplete$ then return $L$ The procedure stops with the list of hull vertices as soon as the value of $H$ in the for-loop reaches or exceeds $h$. The number of iterations in the loop is $\\lceil \\log \\log h\\rceil$ (using base-2 logarithms), and the $t$-th iteration takes $O(n \\log H) = O(n2^t )$ time. Therefore, the total running time of the algorithm is $O(\\sum_{t=1}^{\\lceil \\log\\log h\\rceil}n2^t)=O(n2^{\\lceil\\log\\log h\\rceil+1})=O(n\\log h)$. The storage requirement is clearly linear.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } 
  
]
