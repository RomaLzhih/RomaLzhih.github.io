[
  
    {
      "title"       : "Regular Languages",
      "category"    : "",
      "tags"        : "Computability and Complexity",
      "url"         : "./Regular-Language.html",
      "date"        : "2023-07-08 07:21:20 +0000",
      "description" : "Introduction for Regular Languages",
      "content"     : "Finite AutomataFinite automata are good models for computers with an extremely limited amount of memory. The controller moves from state to state, depending on the input it receives. Finite automata and their probabilistic counterpart Markov Chains are useful tools when we are attempting to recognize patterns in data.Formal Definition of a finite automaton​ A finite automaton is a list of those five objects: set of states, input alphabet, rules for moving, start state, and accept states.Definition A finite automaton is a 5-tuple $(Q,\\sum,\\delta,q_0,F)$, where: $Q$ is a finite set called the state, $\\sum$ is a finite set called the alphabet, $\\delta: Q\\times\\sum\\rightarrow Q$ is the transition function, $q_0\\in Q$ is the start state, and $F\\subseteq Q$ is the set of accept states.Definition If $A$ is the set of all strings that machine $M$ accepts, we say that $A$ is the language of machine $M$ and write $L(M)=A$. We say that $M$ recognizes $A$ or that $M$ accepts $A$. A machine may accepts several strings, but it always recognizes only one language. If the machine accepts no strings, it still recognizes only one language the empty language $\\emptyset$.Formal Definition of Computation​ Let $M=(Q,\\sum,\\delta,q_0,F)$ be a finite automaton and let $w=w_1w_2\\cdots w_n$ be a string where each $w_i$ is a member of the alphabet $\\sum$. Then $M$ accepts $w$ if a sequence of states $r_0,r_1,\\cdots, r_n$ in $Q$ exists with three conditions: $r_0=q_0$ $\\delta(r_i,w_{i+1})=r_{i+1}$, for $i=0,1,\\cdots,n-1$, and $r_n\\in F$.We say that $M$ recognizes language $A$, if $A=\\{ w\\mid M~ accepts~ w\\}$.Definition A language is called a regular language if some finite automaton recognizes it.Above definition equivalent to, $\\forall a\\in A$, $M$ accepts $a$.The Regular OperationsDefinition Let $A$ and $B$ be languages. We define the regular operations union, concatenation, and star as follows: Union: $A\\cup B=\\{ x\\mid x\\in A\\textit{ or }x\\in B\\}$. Concatenation: $A\\circ B=\\{ xy\\mid x\\in A~ and ~ y\\in B\\}$ Star: $A^{*}=\\{ x_1x_2,\\cdots,x_k\\mid k\\geq 0\\textit{ and each }x_i\\in A\\}$. The empty string $\\epsilon$ is always a member of $A^*$, no matter what $A$ is. The set can be treated as all possible combination of the substring in $A$.Generally speaking, a collection of objects is closed under some operation if applying that operation to members of the collection returns an object still in the collection.Theorem The class of regular language is closed under the union operation and the concatenation operation, star, and complementation.Lemma Given a finite automaton $M(Q,\\sum,\\delta,q_0,F)$ that recognizes languages $L$, for any $\\sum’\\supseteq\\sum$ there exists an automaton $M’=(Q’,\\sum’,\\delta’,q_0’,F’)$ that also recognizes $L$.If $L$ can be recognized by a finite automaton $M$ with alphabet $\\sum$, then there it can also be recognized by another finite automaton $M’$ using a larger alphabet $\\sum’$.NondeterminismWhen the machine is in a given state and reads the next input symbol, we know what the next state will be – it is determined. We call this deterministic computation. In a nondeterministic machine, several choices may exist for the next state at any point.Every state of deterministic finite automaton (DFA) always has exactly one exiting transition arrow for each symbol in alphabet. In an nondeterministic finite automaton (NFA), a state may have zero, one, or many exiting arrows for each alphabet symbol, including $\\epsilon$.How NFA compute? ​ After reading that symbol, the machine splits into multiple copies of itself and follows all the possibilities in parallel. Each copy of the machine takes one of the possible ways to proceed and continues as before. Finally, if any one of these copies of the machine is in an accept state at the end of the input, the NFA accepts the input string.Formal Definition of a Nondeterministic finite automatonIn a DFA, the transition function takes a state and an input symbol and produces the next state. In an NFA, the transition function takes a state and an input symbol or the empty string and produce the set of possible next states.For any set $Q$ we write $P(Q)$ to be the collection of all subsets of $Q$. Here $P(Q)$ is called the power set of $Q$. For any alphabet $\\sum$ we write $\\sum_\\epsilon$ to be $\\sum\\cup\\{ \\epsilon\\}$.Definition A nondeterministic finite automaton is a 5-tuple $(Q,\\sum,\\delta,q_0,F)$ where: $Q$ is a finite set of states, $\\sum$ is a finite set called the alphabet, $\\delta: Q\\times\\sum_\\epsilon\\rightarrow P(Q)$ is the transition function, $q_0\\in Q$ is the start state, and $F\\subseteq Q$ is the set of accept states.Equivalence of NFAs and DFAsDFA and NFA recognize the same class of languages. We say that two machines are equivalent if they recognize the same language.Theorem Every NFA has an equivalent deterministic finite automaton.The idea is to use DFA to ssimulate every possible state transfer in NFA.ProofLet $N=(Q, \\sum, \\delta, q_0, F)$ be the NFA recognizing some language $A$. We construct a DFA $M=(Q’,\\sum,\\delta’,q_0’,F’)$ recognizing $A$. Let’s first consider the easier case wherein $N$ has no $\\epsilon$ arrows. $Q’=P(Q)$. For $R\\in Q’$ and $a\\in\\sum$, let $\\delta’(R,a)=\\{ q\\in Q\\mid q\\in\\delta(r,a) \\textit{ for some } r\\in R\\}$, or simply,\\[\\delta'(R,a)=\\bigcup_{r\\in R}\\delta(r,a)\\] If $k$ is the # of states of the NFA, it has $2^k$ subset of states. Each subset corresponds to one of the possibilities that the DFA must remember, so the DFA simulating the NFA will have $2^k$ states. $q_0’=\\{ q_0\\}$. $F’=\\{ R\\in Q’\\mid R \\textit{ contains an accept state of } N\\}$. To consider the $\\epsilon$ errors, we define $E(R)$ to be the collection of states that can be reached from members of $R$ by going only along $\\epsilon$ arrows, including the members of $R$ themselves. The new transition function can be written as:$$\\delta'(R,a)=\\{ q\\in Q\\mid q\\in E(\\delta(r,a)) \\textit{ for some }r\\in R\\}$$ Changing $q_0’$ to be $E(\\{ q_0\\})$.After drawing the graph, we may simplify the machine by removing those states that does not contain the input arrow.Corollary A language is regular if and only if some NFA recognizes it.Definition The class of regular language is closed under the union, concatenation and star operation.Regular ExpressionDefinition Say that $R$ is a regular expression if $R$ is: $a$ for some $a$ in the alphabet $\\sum$, $\\epsilon$, $\\emptyset$, the empty language $(R_1\\cup R_2)$, where $R_1$ and $R_2$ are regular expressions, $(R_1\\circ R_2)$, where $R_1$ and $R_2$ are regular expressions, or $(R_1^*)$, where $R_1$ is a regular repression.When we do calculation, the star operation ( * ) has first priority, followed by concatenation $(\\circ)$ and finally union $(\\bigcup)$, unless parentheses change the usual order. For convenience, we let $R^{+}=RR^{*}$ and we write $L(R)$ to be the language of $R$.Generally we have:$$\\begin{align}R\\bigcup\\emptyset&amp;=R\\\\R\\circ\\epsilon&amp;=R\\end{align}$$However,$$\\begin{align}R\\bigcup\\epsilon&amp;\\neq R\\\\R\\circ\\emptyset&amp;\\neq R\\end{align}$$Why? just take $R=\\epsilon$ as an counter example. Pay attention on the difference between the regular language and regular expression.Theorem A language is regular (recognized by DFA/NFA) if and only if some regular expression describes it.Theorem 1.60 If a language is described by a regular expression, then it is regular; If a language is regular, then it is described by a regular expression.Definition 1.64 A generalized nondeterministic finite automaton is a 5-tuple, $(Q,\\sum,\\delta,q_{start},q_{accept})$, where $Q$ is the finite set of states, $\\sum$ is the input alphabet, $\\delta:(Q-\\{ q_{accept}\\})\\times(Q-\\{ q_{start}\\})\\longrightarrow \\mathcal{R}$ is the transition function, $q_{start}$ is the start state, $q_{accept}$ is the accept state.Proof Idea for Theorem 1.60To convert DFAs into GNFA, and then GNFAs into regular expression. DFA $\\to$ GNFA. Add a new start state with an $\\epsilon$ arrow to the old start state and a new accept state with $\\epsilon$ arrows from the old accept states. If there are multiple arrows going between the same two states in the same direction, we replace each with a single arrow whose label is the union of the previous labels. Add arrows labelled $\\emptyset$ between states that had no arrows. GNFA $\\to$ regular expression Assume the GNFA has $k$ states, if $k&gt;2$, we construct an equivalent GNFA with $k-1$ states by removing the state $q_{rip}(q_2)$, which is the bridge state between $q_i$ and $q_j$, add an equivalent expression edge meanwhile. Repeat (i) until $k=2$, the GNFA has a single arrow that goes from the start state to the accept state. The label of this arrow is the equivalent regular expression. Nonregular LanguagesTheorem Pumping lemma: If $A$ is a regular language, then there is a number $p$ (the pumping length) where if $s$ is any string in $A$ of length at least $p$, then $s$ may be divided into three pieces, $s=xyz$, satisfying the following conditions: for each $i\\geq 0, xy^iz\\in A$, $\\mid y\\mid &gt;0$, and $\\mid xy\\mid \\leq p$.This theorem states that all regular languages have a special property. If we can show that a language does not have this property, we are guaranteed that it is not regular. The property states that all strings in the language can be pumped if they are at least as long as a certain special value, called the pumping length. That means every such string contains a section that can be repeated any number of times with the resulting string remaining in the language.Applying Pumping Lemma Contrapositively Assume $L$ is regular, thus $p$ exists. Use $p$ to define some $s\\in L$ such that $\\mid s\\mid\\geq p$. Split $s$ in all possible ways into $xyz$ such that $\\mid y\\mid &gt;0$ and $\\mid xy\\mid \\leq p$. For every split, find some $i\\neq 1$ (often $i=0$ or $i=2$ works) such that $xy^iz\\notin L$. Conclude: $\\mid s\\mid \\geq p$, but there does not exist a split of $s$ into $xyz$ such that all 3 properties hold. (A language is regular if there exists a partition that satisfy $xy^iz\\in L$). Contradiction! The assumption that $L$ is regular must be false. $L$ is not regular."
    } ,
  
    {
      "title"       : "Robot Motion",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Robot-Motion.html",
      "date"        : "2022-12-16 17:48:22 +0000",
      "description" : "Algorithms for Robot Motion",
      "content"     : "Given a robot and set of obstacles, find the shortest path from $s$ to $t$ without collision.Robot without collision volumeStarting from a point $s$ and finds a possible way to the end point $t$.First, build a rectangle boundary and do the planar subdivision, pick the mid point for vertical planar edge and pick the mid point for ever face.Find the shortest path from the face $f_s$ containing $s$ to that $f_t$ containing $t$. Add an edge from $s$ to the nearest face middle point and add an edge from that to $t$.Analysis:Creating trapezoidal map: $O(n\\log n)$ time.Locating trapezoids containing $s$ and $t$: $O(\\log n)$ time.Computing path using BFS: $O(V+E)=O(n)$ time.Robot with polygon shapeConsidering the robot has certain polygon shape in vertical direction, which means the robot polygon are not allowed to rotate in inclined angle, below repeated polygon is the robot:The dark grey area is the open obstacle (boundary can be touched) and the light grey area is the collision area for the robot gravity, which means, if the robot gravity is located inside the light grey area, then the robot would collide the obstacle. The white area is the free space.How we represent such structure?Define: $\\mathcal{R}:$ polygon robot. Reference point is $(0,0)$. $\\mathcal R(x,y):=\\mathcal R+(x,y)$, translation by vector $(x,y)$. $\\mathcal P$: polygon obstacle. $\\mathcal{CP}=\\mathcal P\\oplus(-\\mathcal R)$. Here $A\\oplus =\\{a+b\\mid a\\in A,b\\in B\\}$ is the Minkowsky sum.How do we compute the free space? How complicated can the space be? i.e., how many corners can it have?Naïve algorithmEach edge of $A\\oplus B$ stems from an edge of $A$ or $B$ (or both). Therefore, $A\\oplus B$ has $\\leq n+m$ edges, where $n$ edges of $A$ and $m$ edges of $B$.Compute $C_A\\oplus C_B$ and take the convex hull, $C_A$ and $C_B$ are the corners of $A$ and $B$.Time: $O(mn\\log (mn))$.For every corners $b\\in B$, it will match all corners $a\\in A$, thus the total number of nodes on boundary of the polygon equals to $mn$ and determining a convex hull for a polygon is $CH(P)$.Smarter algorithm Pick two extreme points on the polygon along the arrow direction. Move the edge $e_A$ parallel to make it ends in $B$. Then rotate the arrow and find next perpendicular edge in two polygons and remove the corresponding edge next to the boundary of forbidden area.Time: $O(m+n)$.Theorem $A$ and $B$ polygons with $m$ and $n$ corners, $A$ and $B$ are convex: $A\\oplus B$ has $O(m+n)$ corners, only one is convex: $A\\oplus B$ has $O(mn)$ corners, none is convex: $A\\oplus B$ has $O(m^2n^2)$ corners.These bounds are tight.Defintiion Polygon $o_1$ and $o_2$ are pseudodisks iff $\\partial o_1\\cap int (o_2)$ and $int(o_1)\\cap \\partial o_2$ are connected, ($\\partial o_1$ is the boundary of $o_1$ and $int(o_2)$ represents the intersection area of $o_1$ with $o_2$).If two polygons have no intersection, they are pseudodisks as well, because the union is empty represents there is no element violates the rule.Theorem A set of pairwise pseudodisks with $n$ corners in total $\\Longrightarrow$ union has $2n$ corners.ProofPay 1 means 1 corner has been introduced.Theorem $\\mathcal R$ robot with $O(1)$ corners, obstacles with $n$ corners $\\Longrightarrow$ free space has $O(n)$ corners.Proof Since there are $O(n-2)=O(n)$ triangles for a polygon with $n$ corners, then for each triangle $T_i$, the intersection $T_i\\oplus(-\\mathcal R)$ has complexity $O(3+O(1))=O(1)$ corners.Since $T_i$ and $T_j$ are interior-disjoint triangles, then $T_1\\oplus (-\\mathcal R)$ and $T_2\\oplus(-\\mathcal R)$ are pseudodisks.Finally, $\\bigcup_T(T\\oplus(-\\mathcal R))$ has $O(n)$ corners.Algorithm$k$ obstacles with $n_1,\\cdots,n_k$ corners, in total $n$.Triangulating:$$\\sum_{i=1}^kO(n_i\\log n_i)=O(\\sum_{i=1}^kn_i\\log n_i)\\leq O(\\log n\\sum_{i=1}^kn_i)=O(n \\log n)$$Computing Minkowsky sum between each obstacles and robot, $\\mathcal{CP}_j=\\mathcal P_j\\oplus(-\\mathcal R):O(1)$ time (three corners per $\\triangle$ and one corner per robot, constant number in total), in total $O(n)$.Below algorithm computing the forbidden space:Compute the union of two polygons in step 5 takes $O(n\\log n)$ time using overlay algorithm from chap. 2.The total Running time: $T(n)=2T(n/2)+O(n\\log n)$, solves to $T(n)=O(n\\log^2n)$.Shortest pathThe complexity of computing visibility graph (for every node $i$, rotate a ray starting from $i$ and catch the intersections): Initialization: sort corners by angle, $O(n\\log n)$ time. Compute intersections with horizontal sweep line and sort them by $x$-coordinate, $O(n\\log n)$ time. Perform the rotational sweep, $O(n\\log n)$ time. Do it for all $n$ corners, $O(n^2\\log n)$Complete algorithm for the shortest path: Compute visibility graph: $O(n^2\\log n)$ time. $O(n)$ vertices and $O(n^2)$ edges. Find shortest path using Dijkstra: $O(n\\log n+n^2)=O(n^2)$. In total $O(n^2\\log n)$."
    } ,
  
    {
      "title"       : "Delaunay Triangulations",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Delaunay-Triangulations.html",
      "date"        : "2022-12-16 17:48:21 +0000",
      "description" : "Algorithms for Delaunay Triangulations",
      "content"     : "A terrain is a 2-dimensional surface in 3-dimensional space with a special property: every vertical line intersects it in a point, if it intersects it at all. In other words, it is the graph of a function $f:A\\subset \\mathbb{R}^2\\rightarrow\\mathbb{R}$ that assigns a height $f(p)$ to every point $p$ in the domain, $A$, of the terrain.Nevertheless, some triangulations look more natural than others. We will rank triangulations by comparing their smallest angle. Since there is only finite number of different triangulations of a given point set $P$, this implies that there must be an optimal triangulation, one that maximizes the minimum angle.Triangulations of Planar Point SetLet $P:={p_1,p_2,\\cdots,p_n}$ be a set of points in the plane. Define a maximal planar subdivision as a subdivision $\\mathfrak S$ such that no edge connecting two vertices can be added to $\\mathfrak S$ without destroying its planarity. In other words, any edge that is not in $S$ intersects one of the existing edges.A triangulation of $P$ is now defined as a maximal planar subdivision whose vertex set is $P$. The number of triangles is the same in any triangulation of $P$, this holds for the number of edges.Theorem 9.1 Let $P$ be a set of $n$ points in the plane, not all colinear, and let $k$ denote the number of points in $P$ that lie on the boundary of the convex hull of $P$. Then any triangulation of $P$ has $2n-2-k$ triangles and $3n-3-k$ edges.Let $\\mathfrak T$ be a triangulation of $P$, and suppose it has $m$ triangles. Let $\\alpha_1,\\alpha_2,\\cdots,\\alpha_{3m}$ be the resulting sequence of angles, where $\\alpha_i\\le\\alpha_j$, for $i&lt;j$. We can $A(\\mathfrak T):=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_{3m})$ the angle-vector of $\\mathfrak T$. We say that the angle vector of $\\mathfrak T$ is larger than the angle-vector of $\\mathfrak T’$, denoted as $A(\\mathfrak T)&gt;A(\\mathfrak T’)$, if $A(\\mathfrak T)$ is lexicographically larger than $A(\\mathfrak T’)$, or in other words, if there exists an index $i$ with $1\\leq i\\leq 3m$ such that:$$\\alpha_j=\\alpha_j', \\forall j&lt;i\\quad and \\quad \\alpha_i&gt;\\alpha_i'$$A triangulation $\\mathfrak T$ is called angle-optimal if $A(\\mathfrak T)\\geq A(\\mathfrak T’)$ for all triangulations $\\mathfrak T’$ of $P$.When a triangulation is angle-optimal?Below is a basic operation called edge flip:We call the edge $e=\\overline{p_ip_j}$ an illegal edge if$$\\min_{q\\leq i\\leq 6}\\alpha_i&lt;\\min_{1\\leq i \\leq 6}\\alpha_i'$$In other words, an edge is illegal if we can locally increase the smallest angle by flipping that edge.Obervation 9.3 Let $\\mathfrak T$ be a triangulation with an illegal edge $e$. Let $\\mathfrak T’$ be the triangulation obtained from $\\mathfrak T$ by flipping $e$. Then $A(\\mathfrak T’)&gt;A(\\mathfrak T)$.So how we check whether there is a illegal edge? It is not necessary to compute and compare the angles in value, below Lemma states a better approach:Lemma 9.4 Let edge $\\overline{p_ip_j}$ be incident to triangles $p_ip_jp_k$ and $p_ip_jp_l$, and let $C$ be the circle through $p_i,p_j$ and $p_k$. The edge $\\overline{p_ip_j}$ is illegal if and only if the point $p_l$ lies in the interior of $C$. Furthermore, if the points $p_i,p_j,p_k,p_l$ form a convex quadrilateral and do not lie on a common circle, then exactly one of $\\overline{p_ip_j}$ and $\\overline{p_kp_l}$ is an illegal edge.Prove by applying the Thales’s Theorem.Define a legal triangulation to be the triangulation that does not contain any illegal edge. Computing a legal edge is quite simple, once we are given an initial triangulation. We simply flip illegal edges until all edges are legal. Why does this algorithm terminate? It follows from Observation 9.3 that the angle-vector of $\\mathfrak T$ increases in every iteration of the loop. Since there is only a finite number of different triangulations of $P$, then this algorithm terminates.The Delaunay TriangulationLet $P$ be a set of $n$ points – or sites. The Voronoi diagram of $P$ is denoted by $Vor(P)$. The region of a sit $p$ is called the Voronoi cell of $p$; it is denoted by $V(p)$. The dual graph of $Vor(P)$, $\\mathfrak G$, has a node for every Voronoi cell and it has an arc between two nodes if the corresponding cells share an edge. The straight-line embedding of $\\mathfrak G$, is called the Delaunay graph of $P$, and we denote it by $DG(P)$. Theorem 9.5 The Delaunay graph of a planar point set is a plane graph.If $P$ in general position, then all vertices of the Voronoi diagram have degree three, and consequently all bounded faces of $DG(P)$ are triangles. This explains why $DG(P)$ is often called the Delaunay triangulation of $P$. Here we carefully call $DG(P)$ as Delaunay graph and we define a Delaunay triangulation to be any triangulation obtained by adding edges to the Delaunay graph.Theorem 9.6 Let $P$ be a set of points in the plane. Three points $p_i,p_j,p_k\\in P$ are vertices of the same face of the Delaunay graph of $P$ if and only if the circle through $p_i,p_j,p_k$ contains no point of $P$ in its interior. Two points $p_i,p_j\\in P$ form an edge of the Delaunay graph $P$ if and only if there is a closed disc $C$ that contains $p_i$ and $p_j$ on its boundary and does not contain any other point of $P$.Theorem 9.7 Let $P$ be a set of points in the plane, and let $\\mathfrak T$ be a triangulation of $P$. Then $\\mathfrak T$ is a Delaunay triangulation of $P$ if and only if the circumcircle of any triangle of $\\mathfrak T$ does not contain a point $P$ in its interior.Theorem 9.8 Let $P$ be a set of points in the plane. A triangulation $\\mathfrak T$ of $P$ is legal if and only if $\\mathfrak T$ is a Delaunay triangulation of $P$.Proof Prove by contradiction.Assume $\\mathfrak T$ is a legal triangulation of $P$ that is not a Delaunay triangulation, this means $p_l$ lines in $C(p_ip_jp_k)$, pick $p_l$ to make $\\angle p_ip_lp_j$ maximum, such an angle in contained in a $\\triangle p_ip_jp_l$ which is not intersect with $\\triangle p_ip_jp_k$. $p_m$ is the adjacent triangle to $\\triangle p_ip_jp_k$ and thus $p_m\\notin C(p_ip_jp_k)$, Now, assume $e=\\overline{p_mp_j}$, however $\\angle p_mp_lp_j&gt;\\angle p_ip_lp_j$, contradict to the assumption that $\\angle p_ip_lp_j$ is maximum. Finish.Since any angle-optimal triangulation must be legal, Theorem 9.8 implies that any angle-optimal triangulation of $P$ is a Delaunay triangulation of $P$. When $P$ is in general position, there is only one legal triangulation, which is then the only angle-optimal triangulation, namely the unique Delaunay triangulation that coincides with the Delaunay graph.Theorem 9.9 Let $P$ a set of points in the plane. Any angle-optimal triangulation of $P$ is a Delaunay triangulation of $P$. Furthermore, any Delaunay triangulation of $P$ maximizes the minimum angle over all triangulations of $P$.Computing Delaunay TriangulationWe now start with a large triangle that contains the set $P$. We add two extra points $p_{-1}$ and $p_{-2}$, which locates far enough away. Now our task is to triangulate the point set $P\\cup{p_{-1},p_{-2}}$. After the triangulation, we shall just remove them.The algorithm is randomized incremental, so it adds the points in random order and it maintains a Delaunay triangulation of the current point set.Consider the addition of a point $p_r$. We first find the triangle of the current triangulation that contains $p_r$ and we add edges from $p_r$ to the vertices of this triangle.We now have a triangulation again, but not necessarily a Delaunay triangulation. This is because the addition of $p_r$ can make some of the existing edges illegal. Below is algorithm:Turing Triangulation into Delaunay formsSuch goal is finished by flipping illegal edges. The question remains is which edges may become illegal due to the insertion of $p_r$. Observe that an edge $\\overline{p_ip_j}$ that was legal before can only become illegal if one of the triangles incident to it has changed. So only the edges of the new triangles need to be checked.This is done using the subroutine $LEGALIZEDGE$, which tests and possibly flips an edge. If it flips an edge, other edges may become illegal, therefore the function calls itself recursively with such potentially illegal edges.Lemma 9.10 Every new edge created in $\\text{DELAUNAYTRIANGULATION}$ or in $\\text{LEGALIZEEDGE}$ during the insertion of $p_r$ is an edge of the Delaunay graph of ${p_{-2},p_{-1},\\cdots,p_r}$.The correctness of algorithm has been proved.Remaining two problems: How to find the triangle containing the point $p_r$ in line $7$ of $\\text{DELAUNAYTRIANGULATION}$ and, how to deal correctly with the points $p_{-1}$ and $p_{-2}$ in the test in line 2 in $\\text{LEGALIZEEDGE}$.Find triangle containing $p_r$While we build the Delaunay triangulation, we also build a point location structure $D$, which is a directed acyclic graph. The leaves of $D$ correspond to the triangles of the current triangulation $\\mathfrak T$, and we maintain cross-pointers between those leaves and the triangulation. The internal nodes of $D$ correspond to triangles that were in the triangulation at some earlier stage, but have already been destroyed.At some point we split a triangle $p_ip_jp_k$ of the current triangulation into three (or two) new triangles. The corresponding change in $D$ is to add three (or two) new leaves to $D$, and to make the leaf for $p_ip_jp_k$ into an internal node with outgoing pointers to those three (or two leaves).To use $D$ to locate the next point $p_r$ to be added in the current triangulation. We start at the root of $D$, which corresponds to the initial triangle $p_0p_{-1}p_{-2}$. We check the three children of the root to see in which triangle $p_r$ lies, and we descend to the corresponding child. We then check the children of this node, descend again, until we reach a leaf of $D$. Since the out-degree of any node is at most three, this takes linear time in the number of nodes on the search path, or other words, in the number of triangles stored in $D$ that contain $p_r$.Choose $p_{-1}$ and $p_{-2}$What we do is to treat these points symbolically: we do not actually assign coordinates to them, but instead modify the tests for point location and for illegal edges such that they work as if we had chosen the points to be very far away.The AnalysisLemma 9.11 The expected number of triangles created by algorithm $\\text{DELAUNAYTRIANGULATION}$ is at most $9n+1$.Theorem 9.12 The Delaunay triangulation of a set $P$ of $n$ points in the plane can be computed in $O(n\\log n)$ expected time, using $O(n)$ expected storage."
    } ,
  
    {
      "title"       : "Voronoi Diagram",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Voronoi-Diagram.html",
      "date"        : "2022-12-16 17:48:20 +0000",
      "description" : "Algorithms for Voronoi Diagram",
      "content"     : "Problem: Given a set $S$ of $N$ points in the plane, for each point $p_i$ in $S$ what is the locus of points $(x,y)$ in the plane that are close to $p_i$ than to any other point $S$ ?Definition locus is the set of points whose location satisfies by one or more specified conditions.Given two points, $p_i$ and $p_j$, the set of points closer to $p_i$ than to $p_j$ is just the half-plane containing $p_i$ that is defined by the perpendicular bisector of $\\overline{p_ip_j}$. Denote the halfplane by $H(p_i,p_j)$. The locus of points closer to $p_i$ than to any other point, which we denote by $V(i)$, is the intersection of $N-1$ half-planes, and is a convex polygonal region having no more than $N-1$ sides, that is:\\[ V(i)=\\cap_{i\\neq j}H(p_i,p_j) \\]$V(i)$ is called the Voronoi polygon associated with $p_i$.These $N$ regions partition the plane into a convex net which we shall refer to as the Voronoi diagram, denoted as $Vor(S)$. The vertices of the diagram are Voronoi vertices, and its line segment are Voronoi edges. Each of the original $N$ points belongs to a unique Voronoi polygon; thus if $(x,y)\\in V(i)$, then $p_i$ is a nearest neighbor of $(x,y)$. The Voronoi diagram contains, in a powerful sense, all of the proximity information defined by the given set.A catalog of Voronoi propertiesAssumption No four points of the original set $S$ are cocircular.Theorem 5.7 Every vertex of the Voronoi diagram is the common intersection of exactly three edges of the diagram. The equivalent form is, the Voronoi vertices are the centres of circles $C(v)$ defined by three points of the original set, and the Voronoi diagram is regular of degree three.A graph is regular if all vertices have the same degree.Proof Let $e_1,\\cdots,e_k$ be edges incident on Voronoi vertex $v$. Note that $x$ is equidistant from $p_{i-1}, p_i$ since it belongs to $e_i$, thus, $v$ is equidistant from $p_1,p_2,\\cdots,p_k$. But this means that $p_1,\\cdots,p_k$ are cocircular, violating assumption that $k\\leq 4$. If $k\\leq 3$, say $k=2$, then $e_1$ is common to $V(2)$ and $V(1)$, and so is $e_2$: indeed they both belong to the perpendicular bisector of the segment $\\overline{p_1p_2}$, so that they do not intersect $v$ (they are coincident).Theorem 5.8 For every vertex $v$ of the Voronoi diagram of $S$, the circle $C(v)$ contains no other points of $S$.Proof If $C(v)$ contains some other point, say $p_4$, then $p_4$ is closer to $v$ than to any of $p_1,p_2$ and $p_3$, in which case $v$ must lie in $V(4)$ and not in any of $V(1),V(2)$, or $V(3)$, by the definition of a Voronoi polygon.Theorem 5.9 Every nearest neighbor of $p_i$ in $S$ defines an edge of the Voronoi polygon $V(i)$.Proof Assume $p_j$ be a nearest neighbor of $p_i$ and let $v$ be the midpoint of their adjoining segment. Suppose that $v$ does not lie on the boundary of $V(i)$. Here we have $length(\\overline{p_iu})&lt;length(\\overline{p_iv})$, so:$$length(\\overline{p_ip_k})\\leq 2length(\\overline{p_iu})&lt;2length(\\overline{p_iv})=length(\\overline{p_ip_j})$$and we could have $p_k$ closer to $p_i$ than $p_j$ is, which is contradictory.Theorem 5.10 Polygon $V_i$ is unbounded if and only if $p_i$ is a point on the boundary of the convex hull of the set $S$.Since only unbounded polygons can have rays as edges, the rays of the Voronoi diagram correspond to pairs of adjacent points of $S$ on the convex hull.Theorem 5.11 The straight-line dual of the Voronoi diagram is a triangulation of $S$.Euler's formula If $G(V,E)$ is planar on $n\\geq 3$ vertices, then $\\mid E\\mid\\leq 3n-6$ and $\\mid f\\mid\\leq 2N-4$.Below one less face is exempt from the outer most open one.Corollary 5.2 A Voronoi diagram on $N$ points has at most $2N-5$ vertices and $3N-6$ edges.Proof Each edge in the straight-line dual corresponds to a unique Voronoi edge. Being a triangulation, the dual is a planar graph on $N$ vertices, and thus by Euler’s formula it has at most $3N-6$ edges and $2N- 4$ faces. Therefore, the number of Voronoi edges is at most $3N- 6$; however, only the bounded faces (at most $2N - 5$) dualize to Voronoi vertices.Any given Voronoi polygon may have as many as $N-1$ edges ($N$ points in total $N^2$ edges), but there are at most $3N-6$ edges overall, each of which is shared by exactly two polygons. This means that the average # of edges in a Voronoi polygon does not exceed $(2\\times3N-6)/(N-1)=6$.Constructing the Voronoi diagramTheorem 5.12 Constructing a Voronoi diagram on $N$ points in the plane must take $\\Omega(N\\log N)$ operations, in the worst case, in the algebra computation-tree model.Procedure VORONOI DIAGRAM (preliminary) Partition $S$ into two subsets $S_1$ and $S_2$ of approximately equal sizes. Construct $Vor(S_1)$ and $Vor(S_2)$ recursively. “Merge” $Vor(S_1)$ and $Vor(S_2)$ to obtain $Vor(S)$. Construct the polygon chain $\\delta$, separating $S_1$ and $S_2$. Discard all edges of $Vor(S_2)$ that lie (extend) to the left of $\\delta$ and all edges of $Vor(S_1)$ that lie to the right of $\\delta$. The result is $Vor(S)$, the Voronoi diagram of the entire set. What reason is there to believe that $Vor(S_1)$ and $Vor(S_2)$ bear any relation to $Vor(S)$ ?Definition 5.2 Given a partition ${S_1,S_2}$ of $S$, let $\\delta(S_1,S_2)$ denote the set of Voronoi edges that are shared by pairs of polygons $V(i)$ and $V(j)$ of $Vor(S)$, for $p_i\\in S_1$ and $p_j\\in S_2$.This collection $\\delta(S_1,S_2)$ of edges enjoys the following properties.Theorem 5.13 $\\delta(S_1,S_2)$ is the edge set of a subgraph of $Vor(S)$ with the properties: $\\delta(S_1,S_2)$ consists of edge-disjoint cycles and chains. If a chain has just one edge, this is a straight line; otherwise its two extreme edges are semi-infinite rays. If $S_1$ and $S_2$ are linearly separated, then, $\\delta(S_1,S_2)$ consists of a single monotone chain.Proof Color the polygons ${V(i):p_i\\in S_1}$ in red and each of the polygons $V(j):p_j\\in S_2$ in green. It is well-known that the boundaries between polygons of different colors are edge-disjoint cycles and chains. Each component of $\\delta(S_1, S_2)$ partitions the plane into two parts. Thus a chain either consists of a single straight line or it has rays as initial and final edges. This establishes 01. Just need to prove it is a chain which is monotone and unique. In figure (a), by the shape of $C$, $p_2$ and $p_3$ belong to the same set, contrary to the assumption that $S_1$ and $S_2$ are separated by a vertical line. So, a vertex like $v$ is impossible and $C$ is vertically monotone. This implies that $C$ is a chain. In figure (b), $p_1$ and $p_3$ belong to the same set of the partition ${S_1,S_2}$, contradicting the hypothesis of vertical separation of these two sets. So, $\\delta(S 1 , S2 )$ consists of a single monotone chain. Define $\\delta:=\\delta(S_1,S_2)$, $\\delta$ cuts the plane into a left portion $\\pi_L$ and a right portion $\\pi_R$.Theorem 5.14 If $S_1$ and $S_2$ are linearly separated by a vertical line with $S_1$ to the left of $S_2$, then the Voronoi diagram $Vor(S)={Vor(S_1)\\cap\\pi_L}\\cup{Vor(S_2)\\cap\\pi_R}$ . Clearly, the success of this procedure depends on how rapidly we are able to construct $\\delta$.Constructing the Dividing ChainThe rays (extreme edges) of $\\delta$ are determined as:The idea we find remaining segments are:Optimization AnalysisAssuming that $\\delta$ is traversed in the direction of decreasing $y$, the walk obtains from the current edge $e$ and current vertex $v$, the next edge $e’$ and vertex $v’$. If $e$ separates $V(i)$ and $V(j)$, for $p_i\\in S_1$ and $p_j\\in S_2$, then $v’$ will be either the intersection of $e$ with the boundary of $V(i)$ in $Vor(S_1)$ or the one with boundary of $V(j)$ in $Vor(S_2)$, whichever is closer to $v$. So by scanning the boundaries of $V(i)$ in $Vor(S_1)$ and of $V(j)$ in $Vor(S_2)$ we can readily determine vertex $v’$.Unfortunately, $\\delta$ may remain inside a given polygon $V(i)$, turning many times, before crossing an edge of $V(i)$. In fact, this procedure could take as much as quadratic time.Indeed, as following figure shows, the $\\delta$ would always closer to $p_i$ since it should remain the bisector between $p_i$ and other points in $Vor(S_2)$. This proves that $C_2$, i.e., the boundary of $V(i)$ in $Vor(S_1)$, needs to be scanned clockwise, with no backtrack, when determining $q_1,q_2,\\cdots$. An analogous argument shows that the boundary of any $V(j)$ in $Vor(S_2)$ needs to be scanned counterclockwise, with no backtrack.The algorithm determine $\\delta$ shown as follows: $e^,v^$ is the start ray edge and point at infinity. $e_L,e_R$ are edges in $Vor(S_1),Vor(S_2)$ and $e$ is the current edge of $\\delta$. It maintains two points of $S$, $p_L\\in S_1$ and $p_R \\in S_2$, so that the current edge $e$ is perpendicular bisector of $\\overline{p_Lp_R}$. By $I(e,e’)$ we denote the intersection of edges $e$ and $e’$; $I(e,e’)=\\Lambda$ means that $e$ and $e’$ do not intersect.To find the intersection boundary, scan the polygon edge in certain direction exactly once without trace back to ensure the construction time of the chain to be linear.Since there are no more than $3N-6$ edges in $Vor(S_1)$ and $Vor(S_2)$ together, and $O(N)$ vertices in $\\delta$, then the entire construction of $\\delta$ takes only linear time.Theorem 5.15 The Voronoi diagram of a set of $N$ points in the plane can be construct in $O(N\\log N)$ time, and this is optimal.Proof$$T(N)=2T(N/2)+O(N)=O(N\\log N)$$"
    } ,
  
    {
      "title"       : "Point Location",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Point-Location.html",
      "date"        : "2022-12-16 00:48:20 +0000",
      "description" : "Algorithms for Point Location",
      "content"     : "Point Location query Given a map and a query point $q$ specified by its coordinates, find the region of the map containing $q$. A map, of course, is nothing more than a subdivision of the plane into regions, a planar subdivision.Idea To preprocess the maps and to store them in a data structure that makes it possible to answer point location queries fast.Slab MethodLet $S$ be a planar subdivision with $n$ edges. The planar _ point_ _ location_ _ problem_ is to store $S$ in such a way that we can answer queries of the following type: ​ Given a query point $p$, report the face $f$ of $S$ that containing $q$. If $q$ lies on an edge or coincides with a vertex, the query algorithm should return this information.Method: We draw vertical lines through all vertices of the subdivision. This partitions the plane into vertical slabs. We store the $x$-coordinates of the vertices in sorted order in an array. This means it possible to determine in $O(\\log n)$ time the slab that contains a query point $q$. Within a slab, there are no vertices of $S$. We label each edge with the face $S$ that is immediately above it inside the slab. The query algorithm is: We do a binary search with the $x$-coordinate of the query point $q$ in the array storing the $x$-coordinates of the vertices of the subdivision. This tells us the slab containing $q$. Do a binary search with $q$ in the array for that slab. The elementary operation in this binary search is: Given a segment $s$ and a point $q$ such that the vertical line through $q$ intersects $s$, determine whether $q$ lies above $s$, below $s$,or on $s$. This tells us the segment directly below $q$, provided there is one. The label stored with that segment is the face of $S$ containing $q$. If we find that there is no segment below $q$ then $q$ lies in the unbounded face.The complexity: Preprocessing: slabs in a sorted list. Trapezoids within the same slab in a sorted list. Sorting in $O(n)$ slabs, each slab with $O(n)$ elements (edges it contain), takes $O(n^2\\log n)$ time. Only perform two binary searches, thence the query time is $O(\\log n)$. Storage requirement: we have an array on the $x$-coordinates of the vertices, which uses $O(n)$ storage. But we also have an array for every slab. Such an array stores the edges intersecting its slab, so it uses $O(n)$ storage. Since there are $O(n)$ slabs, the total amount of storage is $O(n^2)$.Chain MethodThe key to this method is the notion of ‘chain’ as given by the following:Definition A chain $C=(u_1,\\cdots,u_p)$ is a PSLG (planar straight-line graphs) with vertex set ${u_1,\\cdots,u_p}$ and edge set ${(u_i,u_{i+1}):i=1,\\cdots,p-1}$.Definition A chain $C=(u_1,\\cdots,u_p)$ is said to be monotone w.r.t a straight line $l$ if a line orthogonal to $l$ intersects $C$ in exactly one point.​ The operation of deciding on which side of a $p$-vertex chain $C$ a query point $z$ lies – called discrimination of $z$ against $C$, is effected in time $O(\\log p)$.Property For any two chains $C_i$ and $C_j$ of $\\mathcal{L}$, the vertices of $C_i$ which are not vertices of $C_j$ lie on the same side of $C_j$.​ $\\mathcal{L}$ is referred to as a monotone complete set of chains of $G$. Thus if there are $r$ chains in $\\mathcal{L}$ and the longest chain has $p$-vertices, then the search uses worst-case time $O(\\log p\\cdot\\log r)$.Definition Let $G$ be a PSLG with vertex set ${v_1,\\cdots,v_n}$, where the vertices are indexed from right-bottom to the upper-left. A vertex $v_j$ is said to be regular if there are integers $i&lt;j&lt;k$ such that $(v_i,v_j)$ and $(v_j,v_k)$ are edges of $G$. Graph $G$ is said to be regular if each $v_j$ is regular for $1&lt;j&lt;N$ (i.e., with the exception of the two extreme vertices $v_1$ and $v_n$).​ How we transform a non-regular graph into a regular one (to keep the monotone chain divide possible)? In the sweep, for each vertex $v$ reached we perform the following operation: locate $v$ in an interval in the status structure update the status structure if $v$ is not regular, add an edge from $v$ to the vertex associated with the interval determined in (1).Theorem An $N$-vertex PSLG can be regularized in time $N\\log N$ and space $O(N)$.Then, we find all chains for $G$ in $O(#nodes+#edges)$, as follows:The complexity: Location of a point in a regularized graph with $r$ chains and $p$ nodes per chain requires $O(\\log p\\log r)$ time. There are worst regular graphs with $n/2$ chains and $n/2$ nodes per chain. Location requires then $O(\\log n\\log n)$ time. Preprocessing requires: Regularization: $O(n\\log n)$. Monotone chains: $O(n)$. Space: $O(n^2)$.Chain Method - Reducing Space ComplexityDefine: $e_l:=$ last left-forcing edge when going down the chain tree. $e_r:=$ last right-forcing edge when going down the chain tree.3 pointers added to the each edge $e$: $F(e)$ First (topmost) chain through $e$. $L(e)$ Leftmost chain through $e$. $R(e)$ Rightmost chain through $e$.When arriving at $C_j$ where $q$ faces a hole, $C_j$ must be between $F(e_r)$ and $R(e_r)$ or between $L(e_l)$ and $F(e_l)$. In former case, go right from $C_j$, otherwise go left.Space: $O(n)$. Preprocessing and query times not affected.To reduce the time complexity:$c(u)$ original number of nodes (primary structure).$t(u)$ total number of nodes, which includes those nodes added when adding the bridges. Note that $t(u)=c(u)$ if $u$ is a leaf.Below is the analysis:$$\\begin{align}t(u)&amp;&lt;c(u)+(t(v)+t(w))/d+2\\\\\\sum_{u}t(u)&amp;&lt;\\sum_{u}c(u)+\\frac{1}{d}(\\sum_ut(u)-t(root))+2n\\\\(1-\\frac{1}{d})\\sum_ut(u)&amp;&lt;\\sum_uc(u)+2n\\\\\\sum_ut(u)&amp;&lt;\\frac{d}{d-1}(\\sum_uc(u)+2n)\\in \\mathcal{O}(n)\\end{align}$$where $d$ is every $d$ time. $+2$ means there are 2 topmost bridges for primary chain.Randomized Incremental AlgorithmThe first algorithm’s vertical strips idea gave a refinement of the original subdivision, but the number of faces went up from linear in $n$ to quadratic in $n$.Definition Suppose we draw vertical extensions from every vertex up and down, but only until the next line segment, Assume the input line segments are not vertical. Assume every vertex has a distinct $x$-coordinate. Assume we have a bounding box $R$ that encloses all line segments that define the subdivision.This is called the vertical decomposition or trapezoidal decomposition.Every face has a vertical left and/or right side that is a vertical extension, and is bounded from above and below by some line segment of the input. The left and right sides are defined by some endpoint of a line segment.Two trapezoids (including triangles) are neighbours if they share a vertical side. A trapezoid could have many neighbours if vertices had the same $x$-coordinate.Our structure is: Every face $\\Delta$ is an object; it has fields for top($\\Delta$), bottom($\\Delta$), leftp($\\Delta$), and rightp($\\Delta$) (two lines segments and two vertices). Every face has fields to access its up to four neighbours. Every line segment is an object and has fields for its endpoints (vertices) and the name of the face in the original subdivision directly above it. Each vertex stores its coordinates.Lemma 6.1 Each face in a trapezoidal map of a set $S$ of line segments in general position (no two distinct endpoints lie on a common vertical line) has one or two vertical sides and exactly two non-vertical sides.Lemma 6.2 The trapezoidal map $\\mathcal{T}(S)$ of a set $S$ of $n$ line segments in general position contains at most $6n+4$ vertices and at most $3n+1$ trapezoids.Proof A vertex of $\\mathcal{T}(S)$ is either: A vertex of $R$, where $R$ is the outer rectangular. An endpoint of a segment in $S$, or else The point where the vertical extension starting in an endpoint abuts on another segment or an the boundary of $R$. Every endpoint of a segment induces two vertical extensions – one upward and one downward. ($2n$ points and 2 lines up&amp;down)In total $4+2n+2(2n)=6n+4$.For bound of trapezoids number: here we give a direct proof, using the point leftp(∆). the lower left corner of $R$ plays this role for exactly one trapezoid, (1) a right endpoint of a segment can play this role for at most one trapezoid, ($n$) a left endpoint of a segment can be the leftp(∆) of at most two different trapezoids. ($2n$)In total: $1+n+2n=3n+1$.We will use randomized incremental construction to build, for a set $S$ of non-crossing line segments: A vertical decomposition $T$ of $S$ and $R$ A search structure $D$ whose leaves correspond to the trapezoids of $T$Start with $R$, then add the line segments in random order and maintain $T$ and $D$.Let $s_1,\\cdots, s_n$ be the $n$ line segments in random order. Let $T_i$ be the vertical decomposition of $R$ and $s_1,\\cdots,s_i$, and let $D_i$ be the search structure obtained by inserting $s_1,\\cdots,s_i$ in this order.We want only one leaf in $D$ to correspond to each trapezoid; this means we get a directed acyclic graph (DAG) (one leaf could only have one father node) instead of a search tree (one father per son). Right is the the point location query.The incremental step:Suppose we have $D_{i-1}$ and $T_{i-1}$, how do we add $s_i$?Because $D_{i-1}$ is a valid point location structure for $s_1,\\cdots,s_{i-1}$, we can use it to find the trapezoid of $T_{i-1}$ that contains $p_i$, the left endpoint of $s_i$ (query process). Then we use $T_{i-1}$ to find all other trapezoids that intersect $s_i$, because every face stores the information of its neighbour. After locating the trapezoid that contains $p_i$, we can determine all $k$ trapezoids that intersect $s_i$ in $O(k)$ time by traversing $T_{i-1}$. The update of the vertical decomposition can be finished in $O(k)$ as well. More specifically: If line segment $s_i$ is completely contained in a trapezoid $\\Delta=\\Delta_0$, then we can update as follows: To update $T$, we delete ∆ from $T$, and replace it by four new trapezoids $A,B,C,$ and $D$. To update $D$, what we must do is replace the leaf for $\\Delta$ by a little tree with four leaves. If $s_i$ intersects $k_i$ trapezoid: To update $T$, we first erect vertical extensions through the endpoints of $s_i$ and re-index them, $O(k_i)$. To update $D$, If $\\Delta_0$ has the left endpoint of $s_i$ in its interior (which means it has been partitioned into three new trapezoids) then were place the leaf for $\\Delta_0$ with an $x$-node for the left endpoint of $s_i$ and a $y$-node for the segment $s_i$. Similarly, if $\\Delta_k$ has the right endpoint of $s_i$ in its interior, were place the leaf for $\\Delta_k$ with an $x$-node for the right endpoint of $s_i$ and a $y$-node for $s_i$. Finally, the leaves of $\\Delta_1$ to $\\Delta_{k-1}$are replaced with single $y$-nodes for the segment $s_i$. (Update by replacing $k_i$ leaves by $O(k_i)$ new internal nodes and $O(k_i)$ new leaves.) The maximum depth increase is three nodes. Space and Time analysisFor any trapezoid $\\Delta$, there are at most $4$ line segments whose insertion would have created it (top($\\Delta$), bottom($\\Delta$), leftp($\\Delta$), rightp($\\Delta$)).SpaceLet $n_i$ be # of “new” trapezoids of $T_i$, i.e., the ones that are not trapezoids of $T_{i-1}$. Then we have:$$|D_i|-|D_{i-1}|=O(n_i)$$Here we have $n_i=\\Theta(k_i)$, where $k_i$ is the # of trapezoids of $T_{i-1}$ intersected by $s_i$.$T_i$ has $\\leq 3i+1$ trapezoids and when we add line $s_i$, each trapezoid has probability $\\leq 4/i$ of being new, where $i$ is remaining # of line segments. Hence,$$\\mathbb{E}[n_i]\\leq(3i+1)\\cdot4/i\\leq 13$$Therefore,$$\\mathbb{E}[|D_n|]=\\mathbb{E}[O(\\sum_{i=1}^n n_i)]=O(\\sum_{i=1}^n\\mathbb{E}[n_i])=O(13n)=O(n)$$Query TimeDefine $X_i=1$ if the search path for any query point $p$ increases in iteration $i$. Otherwise, $X_i=0$. In other words, $X_i=1$ if and only if trapezoid containing $p$ in $T_i$ is new.$$\\mathbb{E}[\\sum_{i=1}^nX_i]=\\sum_{i=1}^n\\mathbb{E}[X_i]=\\sum_{i=1}^n\\mathbb{P}[X_i=1]$$Hence, $P[X_i=1]\\leq 4/i$, since at most $4$ of the $i$ segments in $T_i$ could have caused the trapezoid containing $p$ to be new (just created).$$\\mathbb{E}[\\sum_{i=1}^nX_i]=\\sum_{i=1}^n\\mathbb{P}[X_i=1]\\leq\\sum_{i=1}^n 4/i=O(\\log n)$$The search path increases by at most $3$ at a time, so the final search is $O(\\log n)$.Theorem Given a planar subdivision defined by a set of $n$ non-crossing line segments in the plane, we can preprocess it for planar point location queries in $O(n\\log n)$ expected time, the structure uses $O(n)$ expected storage, and the expected query time is $O(\\log n)$."
    } ,
  
    {
      "title"       : "Line Segment Intersection",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Line-Segment-Intersection.html",
      "date"        : "2022-12-15 18:38:20 +0000",
      "description" : "Introduction to Line Segment Intersection",
      "content"     : "Problem Given a set $S$ of $n$ closed segments in the plane, report all intersection points among the segments in $S$.Theorem 2.4 Let $S$ be a set of $n$ line segments in the plane. All intersection points in $S$, with for each intersection point the segments involved in it, can be reported in $O(n\\log n+I\\log n)$ time and $O(n)$ space, where $I$ is the number of intersection points.The double-Connected Edge ListSome Definition: A face of the subdivision is connected subset of the plane that doesn’t contain a point on an edge or a vertex. Thus a face is an open polygon region whose boundary is formed by edges and vertices from the subdivision. The complexity of a subdivision is defined as the sum of the number of vertices, the number of edges, and the number of faces it consists of. If a vertex is the endpoint of an edge, then we say that the vertex and the edge are incident. Our goal is to: require that we can walk around the boundary of a given face, we can access one face from an adjacent one if we are given a common edge. visit all the edges around a given vertex.Our answer is called the doubly-connected edge list. A DCEL contains a record for each face, edge, and vertex of the subdivision.The doubly-connected edge list consists of three collections of records: one for the vertices, one for the faces, and one for the half-edges. These records store the following geometric and topological information: The vertex record of a vertex $v$ stores the coordinates of $v$ in a field called Coordinates(v). It also stores a pointer IncidentEdge(v) to an arbitrary half-edge that has $v$ as its origin. The face record of a face $f$ stores a pointer OuterComponent(f) to some half-edge on its outer boundary. For the unbounded face this pointer is nil. It also stores a list InnerComponents(f), which contains for each hole in the face a pointer to some half-edge on the boundary of the hole. The half-edge record of a half-edge $\\overrightarrow{e}$ stores a pointer Origin($\\overrightarrow{e}$) to its origin, a pointer Twin($\\overrightarrow{e}$) to its twin half-edge, and a pointer IncidentFace($\\overrightarrow{e}$) to the face that it bounds. We don’t need to store the destination of an edge, because it is equal to Origin(Twin($\\overrightarrow{e}$)). The origin is chose such that IncidentFace($\\overrightarrow{e}$) lies to the left of $\\overrightarrow{e}$ when it is traversed from origin to destination. The half-edge record also stores pointers Next($\\overrightarrow{e}$) and Prev($\\overrightarrow{e}$) to the next and previous edge on the boundary of IncidentFace($\\overrightarrow{e}$) that has the destination of $\\overrightarrow{e}$ as its origin, and Prev($\\overrightarrow{e}$) is the unique half-edge on the boundary of IncidentFace($\\overrightarrow{e}$) that has Origin($\\overrightarrow{e}$) as its destination."
    } ,
  
    {
      "title"       : "Orthogonal Range Searching",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Orthogonal-Range-Search.html",
      "date"        : "2022-11-11 00:48:20 +0000",
      "description" : "Algorithms for Orthogonal Range Searching",
      "content"     : "Definition A query asking to report all records whose fields lie between specified values, then transforms to a query asking for all points inside a $d$-dimensional axis-parallel box. Such a query is called a rectangular range query, or an orthogonal range query in CG.Normalization $x$- and $y$-coordinates of points can be replaced by integers $1,2,3,\\cdots, n$ in $O(n\\log n)$ time (First sort and re-index). When querying, the coordinates of of the rectangle corners can be transformed to appropriate integers in $O(\\log n)$ time.In the remainder of this section we assume that no two pints in $P$ have the same $x$-coordinate, and no two points have the same $y$-coordinate.Kd-TreesBasic DefinitionA Kd-Tree looks like:Every vertical/horizontal line split current graph into two parts each with equal number of points on both sides until each partition contains only one point. Each node in Kd-tree represents a line. The nodes in even length from root represent the vertical line and others on odd length represent the odd line.Preprocessing TimeThe most expensive step is performed at every recursive call is finding the splitting line. This requires determining the median $x$-coordinate or the median $y$-coordinate, depending on whether the depth is even or odd. We find the median in linear time relative simply in such way, sort by $x$- and $y$- coordinates independently. Hence, the building time $T(n)$ satisfies the recurrence:$$T_n=\\begin{cases}O(1), &amp; if\\quad n=1\\\\O(n)+2T(\\lceil n/2\\rceil), &amp; if \\quad n&gt;1\\end{cases}$$which solves to $O(n\\log n)$. Here $O(n)$ is the expense for median finding and recursive expression $T(\\lceil n/2\\rceil)$ shows the left and right build procedure.Space: Binary tree with $n$ leaves. $O(n)$ space.Lemma A Kd-tree for a set of $n$ points uses $O(n)$ storage and can be constructed in $O(n\\log n)$ time.Query TimeThe region of a node $v$, denoted as $region(v)$, in Kd-Tree is:Such a $region(v)$ is formed by the line represented by the ancestor nodes of $v$.The query algorithm is: we traverse the Kd-Tree, but visit only nodes whose region is interested by the query rectangle. When a region is fully contained in the query rectangle, we can report all the points stored in its subtree. When the traversal reaches a leaf, we have to check whether the points stored at the leaf is contained in the query region and, if so, report it.The main test of the query algorithm performs is whether the query range $R$ intersects the region corresponding to some node $v$. One can maintain the current region through the recursive calls using the lines stored in the internal nodes. For instance, the region corresponding to the left child of a node $ν$ at even depth can be computed from $region(ν)$ as follows:$$\\operatorname{region}(l c(v))=\\operatorname{region}(v) \\cap \\ell(v)^{\\text {left }}$$where $\\ell(v)$ is the splitting line stored at $v$, and $\\ell(v)^{left}$ is the half-plane to the left of and including $\\ell(v)$.The time we need to traverse a subtree and report the points stored in its leaves is linear in the number of reported points, which is $O(k)$. Besides, it remains to bound the number of nodes visited by the query algorithm that are not in one of the traversed subtrees. To analyze the number of such nodes, we shall bound the number of regions interested by any vertical line.Let $\\ell$ be a vertical line, and let $\\mathcal{T}$ be a Kd-Tree. Let $\\ell(root(\\mathcal{T}))$ be the splitting line stored at the root of the Kd-Tree. Observe that if the line $\\ell$ intersects, for instance $region(lc(root(\\mathcal{T})))$, then it will always intersect the regions corresponding to both children of $lc(root(\\mathcal{T}))$.Define $Q(n)$ as the number of interested regions in a Kd-Tree storing $n$ points whose root contains a vertical splitting line. To write recurrence for $Q(n)$ we have to go down two steps in the tree. Each of the four nodes at depth two in the tree corresponds to a region containing $n/4$ points.Two of the four nodes correspond to intersected regions (at least two regions would be interested by such region), so we have to count the number of intersected regions of the remaining 2 nodes ($Q(n/4)+Q(n/4)$) in these subtrees recursively. Hence, $Q(n)$ satisfies the recurrence$$Q(n)=\\begin{cases}O(1), &amp;if \\quad n=1\\\\2 + 2Q(n/4), &amp;if \\quad n&gt;1\\end{cases}$$This recurrence solves to $Q(n)=O(\\sqrt{n})$. In other words, any vertical line intersects $O(\\sqrt{n})$ regions in a Kd-Tree.Theorem A Kd-Tree for a set $P$ of $n$ points in the plane use $O(n)$ storage and can be built in $O(n\\log n)$ time. A rectangular range query on the Kd-Tree takes $O(\\sqrt n+k)$ time, where $k$ is the number of reported points. If its $d$-dimensional, the query time is bounded by $O(n^{1-1/d}+k)$.1-Dimensional Range SearchAbove data structure is a BST and we call it Threaded Binary Tree .For a 1-dimensional range query, $[u,u’]$, we first binary search $u$ in the tree, for each node $v$, report nodes in $rc(v)$ . Then search $u’$ and report all nodes in $lc(v)$.Theorem Let $P$ be a set of $n$ points in 1-dimensional space. The set $P$ can be stored in a balanced BST, which uses $O(n)$ storage and has $O(n\\log n)$ construction time, such that the points in a query range can be reported in time $O(k+\\log n)$, where $k$ is the number of reported points.Range TreeThe range tree is: The main tree $\\mathcal{T}$ is a balanced binary search tree built on the $x$-coordinate of the points in $P$. For any internal or leaf node $v\\in \\mathcal{T}$, the canonical subset $P(v)$, which is the subset of points store in the leaves of the subtree rooted at a node $v$, is stored in a balanced associated BST $\\mathcal{T}(v)$ on the $y$-coordinate of the points. The node $v$ stores a pointer to the root of $\\mathcal{T}(v)$, which is called the associated structure of $v$.Space Because 1-dimensional range trees use linear storage it follows that the associated structures of all nodes at any depth of $\\mathcal{T}$ together use $O(n)$ storage. The depth of $\\mathcal{T}$ is $O(\\log n)$. Hence, the total amount of storage required is bounded by $O(n\\log n)$.Preconstruct Constructing a BST from an unordered list is $O(n\\log n)$ but if the list is sorted, it could be reduced to $O(n)$. Thus, for this two level structure, we first sort the $x$-coordinate and $y$-coordinate and then we build the first level-tree and second level tree in $O(n)$, totally $O(n\\log n)$.Query First selects $O(\\log n)$ canonical subsets that together contain the points whose $x$-coordinate lie in the range $[x,x’]$, This can be done with the 1-dimensional query algorithm. Of those subsets, we then report the points whose $y$-coordinate lie in the range $[y,y’]$ using same methods. Thus in total $O(\\log^2n+k)$.Theorem Let $P$ be a set of $n$ points in the $d$-dimension. A range tree for $P$ uses $O(n(\\log n)^{d-1})$ storage and can be constructed in $O(n(\\log n)^{d-1})$ time. By querying this range tree one can report the points in $P$ that lie in a rectangular query range in $O(\\log^dn+k)$ time, where $k$ is the number of reported points.Improved Range TreeFractional Cascading​ Let $S_1$ and $S_2$ be two sorted lists of numbers. Generally, if we want to report all objects in $S_1$ and $S_2$ whose keys lie in a query interval $[y,y’]$, we need to do two binary searches with $y$ in $S$ and and walk along $S$ until $y’$. The total time is $O(k)$ plus the time for two binary searches, one in $S_1$ and the other in $S_2$.​ If, however, the keys of the objects in $S_2$ are a subset of the keys of the objects in $S_1$, then we can avoid the second binary search as follows. We add pointers from the entries in $S_1$ to the entries in $S_2$: if $S_1[i]$ stores an object with key $y_i$, then we store a pointer to the entry in $S_2$ with the smallest key larger than or equal to $y_i$. If there is no such key, then the pointer from $S_1[i]$ is $nil$. Then in the search of $S_2$, we just follow the pointer created in process of $S_1$, which takes only $O(1+k)$ time.Range Tree has exactly such structure. We use Fractional Cascading to improve it.After sorted in preprocessing, The second-level structure is always the subset of its ancestor nodes. Since we find the same nodes, in the first level binary search we can position the node we should start search in second level. For example, in root node, we find 2 as the left most point, and the pointer in 2 points to 6 since we have sorted it in $y$-monotone already.Theorem Let $P$ be a set of $n$ points in $d$-dimensional space, with $d\\geq 2$. A layered range tree for $P$ uses $O(n\\log^{d-1}n)$ storage and it can be constructed in $O(n\\log^{d-1}n)$ time. With this range tree one can report the points in $P$ lie in a rectangular query range in $O(\\log^{d-1}n+k)$ time, where $k$ is the number of reported points.Reference: Orthogonal Range Search, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Polygon Triangulation",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Polygon-Triangulation.html",
      "date"        : "2022-11-10 02:48:20 +0000",
      "description" : "Algorithms for polygon triangulation",
      "content"     : "Art gallery problemTwo points in a simple polygon can see each other if their connecting line segment is in the polygon.Definition The art gallery problem:​ How many points are needed in a simple polygon with $n$ vertices so that every point in the polygon is seen?This problem is NP-hard.Theorem art gallery theorem:​ $\\lfloor n/3\\rfloor$ cameras are occasionally necessary but always sufficient.Some Definition Polygon $P$ is triangulated: a decomposition of $P$ into disjoint triangles by a maximal set of non-intersecting diagonals. Diagonal of $P$: open line segment that connects two vertices of $P$ and fully lies in the interior of $P$. Dual graph for a plane graph $G$ is a graph which is, each face in primal graph gives a node; two nodes are connected in dual graph if the faces are adjacent. The dual graph of a triangulated simple polygon without hole is a tree. A simple polygon is y-monotone iff any horizontal line intersects it in a connected set (or not at all), or equivalently, if every horizontal line intersects it at most twice.Lemma: A simple polygon with $n$ vertices can always be triangulated, and always into $n-2$ triangles.Proof Every tree has a leaf, in particular the one that is the dual graph. Remove the corresponding triangle from the triangulated polygon, colour its vertices, add the triangle back, and let the extra vertex have the colour different from its neighbours.For a 3-coloured, triangulated simple, one of the color classes is used by at most $\\lfloor n/3\\rfloor$ colors. Place the cameras at these vertices.Triangulate a polygonOverview: Use plane sweep to partition the polygon into $y$-monotone polygons. Triangulate each $y$-monotone polygon.Partition into monotone piecesVertex type: Start, above space of the vertex does not belongs to the polygon, Stop/End, below space of the vertex does not belongs to the polygon, Split, the polygon separate into two parts after this point, Merge, the polygon merge into one part after this point, Regular.The sweep idea is, find diagonals from each merge vertex down, and from each split vertex up. Since these two kinds of points change the monotone of the polygon.Definition The helper for an edge $e$ that has the polygon right of it, and a position of the sweep line, is the lowest vertex $v$ above the sweep line such that the horizontal line segment connecting $e$ and $v$ is inside the polygon.Definition The status is the set of edges intersecting the sweep line that have the polygon to their right, sorted from left to right, and each with their helper: the last vertex passed in that component. The status structure stores all edges that have the polygon to the right, with their helper, sorted from left to right in the leaves of a balanced binary search tree $T$.The event happen only at the vertices: sort them by $y$-coordinate and put them in a list.Now we begin sweep the initial polygon and prepare to handle the different event when the sweep line meets the vertex of: Start vertex $v$: insert the ccw incident edge in $T$ with $v$ as the helper (the left edge behind $v$). End vertex $v$: delete the clockwise incident edge and its helper from $T$ (the left edge above $v$). Regular vertex $v$: if the polygon is right of the two incident edges, then replace the upper edge by the lower edge in $T$, and make $v$ the helper. If the polygon is left of the two incident edges, then find the edge $e$ directly left of $v$, and replace its helper by $v$. Merge vertex $v$: Remove the edge clockwise from $v$ from $T$. Find the edge $e$ directly left of $v$, and replace its helper by $v$. Split vertex $v$: Find the edge $e$ directly left of $v$, and choose as a diagonal the edge between its helper and $v$. Replace the helper of $e$ by $v$. Insert the edge ccw from $v$ in $T$, with $v$ as its helper.Efficiency:​ Sorting all events by $y$-coordinate takes $O(n\\log n)$ time. Every event takes $O(\\log n)$ time, because it only involves querying, inserting and deleting in $T$.Two-direction Sweep:​ We need to sweep in both upward and downward direction, since unidirectional sweep is insufficient divide the polygon into monotone spices. For a same vertex, maximum 2 diagonals would be chosen to the same vertex. Because, if $u$ is a split vertex, an edge is added to $u$ and the helper of $u$; then the sweep continuous, another split vertex below which regards $u$ as its helper would also add one edge to $u$, then $u$ would never become helper.Theorem: A simple polygon with $n$ vertices can be partitioned into $y$-monotone pieces in $O(n\\log n)$ time.Triangulating a monotone polygonThe algorithm: Sort the vertices top-to-bottom by a merge of the two chains, Initialize a stack. Push the first two vertices, Take the next vertex $v$, and triangulate as much as possible, top-down, while popping the stack, Push $v$ onto the stack.Theorem A monotone polygon with $n$ vertices can be triangulated $O(n)$ time.Triangulating a simple polygonWe need to argue that all $y$-monotone polygons together that we will triangulate have $O(n)$ vertices. Initially we had $n$ edges. We add at most $n-3$ diagonals in the sweeps. These diagonals are used on both sides as edges. So all monotone polygons together have at most $n+2(n-3)=3n-6$ edges, and therefore at most $3n-6$ vertices. Note that the complexity all about the total computation load, hence we can conclude that triangulating all monotone polygons together takes only $O(n)$ time.Theorem A simple polygon with $n$ vertices can be triangulated $O(n\\log n)$ time.Reference: Polygon Triangulation, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Convex Hull",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Convex-Hull.html",
      "date"        : "2022-11-09 04:48:20 +0000",
      "description" : "Algorithms for computing a Convex Hull",
      "content"     : "Problem DefinitionGiven: A set $Z$ of $n$ points in the plane.Find: Smallest convex set containing $Z$.Some Basic Definition A set $S$ in the plane is convex iff for every pair of points $p_1$ and $p_2$ in $S$, the line-segment $p_1p_2 $ is in $S$. A point $p$ in a convex set $S$ is said to be extreme (or a corner) iff no segment $ab$ in $S$ has $p$ in its interior. $CH(Z)$ is considered to be determined once its corners ordered around the boundary are found. Simplifying assumptions: No pair of Z-points has the same x- or y-coordinate and/or no three points colinear.Equivalent Formulations for CH Intersection of all convex sets containing $Z$. Intersection of all half-planes containing $Z$. Smallest possible convex set containing $Z$. Convex set with the smallest possible perimeter and containing $Z$.Sorting can be transformed in $O(n)$ time into the convex hull problem. Thus the lower bound of the complexity of CH is same as sorting which is $O(n\\log n)$.Point $p_1,p_2,p_3$ make a right turn at $p_2$ iff $p_3$ is to the right or on the line through $p_1$ and $p_2$. Otherwise $p_1,p_2,p_3$ make a left turn at $p_2$. Mathematically speaking, if:$$det\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\\\x_3 &amp; y_3 &amp; 1\\end{bmatrix}&gt;0 \\Rightarrow \\textit{left turn}$$Algorithm 1: Point PruningSince: A point in set $Z$ which is not a corner is inside a triangle on $Z$. Use $O(n^3)$ time to enumerate the triangles and for every triangles use $O(n)$ transverse other point to check whether it is contained. When whole procedure finishes, the remaining points never included are corners. Actually, we can select the left/up and right/down extreme points to form a bottom edge for triangle and enumerate the third vertex and check the other $Z$-point inclusion in $O(n\\cdot n)$, cuz that the two extreme points must be included in corners. Then, we need to sort the corners. Take any point in $CH(Z)$ and sort corners around it. Draw line through the leftmost and rightmost corners. Sort corners above the line by increasing x-coordinate and sort corners below the line by decreasing x-coordinate. All this can be done in $O(n\\log n)$ time. Algorithm 2: Edge Pruning → Jarvis March (1973)Naïve approach: Arbitrarily pick one edge $O(n^2)$ and check whether all other points are located on same side of edge (left/right turn, $O(n)$ ). In total $O(n^3)$. Sorting of corners remains.Jarvis’s March: When a boundary edge $z_iz_j$ has been identified, there must exist another boundary edge with $z_j$ as one of its endpoints. Boundary edge can be founded by starting from extreme point. Find boundary edge consecutively. Corner sorting still needed. $O(nh)$, where $h$ is the number of corners. Expected number of corners of points independently and uniformly distributed within a unit circle is $O(n^{1/3})$.Algorithm 3: Graham’s Scan (1972)Procedure: Sort points around some point of CH(Z). Points at the same angle are sorted by their distance. Construct the polygon defined by the sorting. Prune the nodes. If we transverse the nodes in counterclockwise (ccw) order, all middle nodes should make a left turn for pairs $p+,p,p-$, otherwise it can be removed. After remove the middle point $p$, $p-$ would go backward, otherwise all three points walk forward. Algorithm terminate when the initial corner arrived by a forward step.Something may goes wrong: Will never go backwards behind the initial corner, which means if we select a wrong initial corner at first, it would be dropped and we will never trace back to it.Complexity: # of backward steps is $O(n)$. # of forward step is $O(n)$. Sorting $O(n\\log n)$. Totally, $O(n\\log n)$.Algorithm 4: Divide and ConquerPartition $Z$ into balanced subsets $Z_1$ and $Z_2$, determine $CH(Z_1)$ and $CH(Z_2)$ recursively. The problem solve directly if $n\\leq 2$.Merge: For each merge phase, two sub-polygon with corners sorted are available. Then select one point arbitrarily, say point 1. Build two sorted edge set between point 1 and other points. If point 1 is inside another polygon, cause this two edges are all sorted, we can merge them directly. If point 2 is outside another polygon, we pick two extreme points (which is exterior most to point 2), say point 3 and point 4. For all other points $q$, we check whether it make a left turn from point 3 to point 2, or form a right turn from point 4 to point 2. If not, we drop this point. (or we can check whether this point is included by the other polygon)Partition and union complexity:$$\\begin{array}{c}T(n)=O(1), n \\leq 2 \\\\T(n)=2 * T(n / 2)+O(n), n&gt;2\\end{array}$$Overall $O(n\\log n)$.Algorithm 5: Marriage-before-Conquest (1986)“Reverse Order” than Divide-and-Conquer.Calculate the Upper and Lower Convex Hulls separately and merge them. Divide the nodes into 2 points, which is approximately same. Find the Bridge across two sides. Drop the nodes exactly below the bridge and compute the left upper CH and right upper CH recursively. Merge.How to find a Bridge? Build edges by pairing two nodes arbitrarily. Select the edge $e$ with median slope. Move $e$ parallelly to the upper/lower extreme point $p$ (no more higher /lower nodes exists). If exactly two nodes from both sides located in same line, the line is bridge and then be returned. Otherwise, for all of other points $p_i$ in same side of $p$, calculate the slope $e_i=(p,p_i)$ . If $p$ is on left side and $e_i&gt;e$, drop $p_i$, or if $p$ is on right side and $e_i&lt;e$, drop $p_i$. Repeat until only 1 node in opposite side of $p$ exists.Complexity containing both Bridge Finding, and Overall Complexity is shown as follows, big constant.Algorithm 6: Chan’sAlgorithms with complexity measured as a function of both $n$ and output size $h$ are said to be output-sensitive.Let $P\\subset E^2$ be a set of $n\\geq 3$ points. The procedure of Chan’s algorithm is:Algorithm Hull2D($P, m, H$), where $P \\subset E^2$, $3 ≤ m ≤ n$, and $H ≥ 1$ partition $P$ into subsets $P_1,\\cdots,P_{\\lceil n/m\\rceil}$ each of size at most $m$ for $i=1,\\cdots, \\lceil n/m\\rceil$ do compute conv($P_i$) by Graham’s scan and store its vertices in an array in ccw order $p_0\\leftarrow (0,-\\infty)$ $p_1\\leftarrow$ the rightmost point of $P$ for $k=1,\\cdots,H$ do for $i=1,\\cdots,\\lceil n/m\\rceil$ do compute the points $q_i\\in P_i$ that maximizes $\\angle p_{k-1}p_kq_i\\quad (q_i\\neq p_k)$ by performing a binary search on the vertices of conv($P_i$) $p_{k+1}\\rightarrow$ the point $q$ from ${q_1,\\cdots,q_{\\lceil n/m\\rceil}}$ that maximizes $\\angle p_{k-1}p_kq$ if $p_{k+1}=p_1$ then return the list $\\langle p_1,\\cdots,p_k\\rangle$ return incompleteBy choosing $m = H$, the complexity of the algorithm is then $O(n(1+H/m) \\log m) = O(n \\log H)$. Since the value of $h$ is not known in advance, we use a sequence of $H$’s to “guess” its value as shown below:Algorithm Hull2D($P$), where $P \\subset E^2$ for $t = 1, 2,\\cdots $ do $L\\rightarrow $ Hull2D($P,m,H$), where $m=H=\\min{2^{2^t},n}$ if $L\\neq incomplete$ then return $L$ The procedure stops with the list of hull vertices as soon as the value of $H$ in the for-loop reaches or exceeds $h$. The number of iterations in the loop is $\\lceil \\log \\log h\\rceil$ (using base-2 logarithms), and the $t$-th iteration takes $O(n \\log H) = O(n2^t )$ time. Therefore, the total running time of the algorithm is $O(\\sum_{t=1}^{\\lceil \\log\\log h\\rceil}n2^t)=O(n2^{\\lceil\\log\\log h\\rceil+1})=O(n\\log h)$. The storage requirement is clearly linear.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } 
  
]
