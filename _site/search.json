[
  
    {
      "title"       : "Line Segment Intersection",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Line-Segment-Intersection.html",
      "date"        : "2022-12-15 18:38:20 +0000",
      "description" : "Introduction to Line Segment Intersection",
      "content"     : "Line Segment intersectionProblem Given a set $S$ of $n$ closed segments in the plane, report all intersection points among the segments in $S$.Theorem 2.4 Let $S$ be a set of $n$ line segments in the plane. All intersection points in $S$, with for each intersection point the segments involved in it, can be reported in $O(n\\log n+I\\log n)$ time and $O(n)$ space, where $I$ is the number of intersection points.The double-Connected Edge ListSome Definition: A face of the subdivision is connected subset of the plane that doesn’t contain a point on an edge or a vertex. Thus a face is an open polygon region whose boundary is formed by edges and vertices from the subdivision. The complexity of a subdivision is defined as the sum of the number of vertices, the number of edges, and the number of faces it consists of. If a vertex is the endpoint of an edge, then we say that the vertex and the edge are incident. Our goal is to: require that we can walk around the boundary of a given face, we can access one face from an adjacent one if we are given a common edge. visit all the edges around a given vertex.Our answer is called the doubly-connected edge list. A DCEL contains a record for each face, edge, and vertex of the subdivision.The doubly-connected edge list consists of three collections of records: one for the vertices, one for the faces, and one for the half-edges. These records store the following geometric and topological information: The vertex record of a vertex $v$ stores the coordinates of $v$ in a field called Coordinates(v). It also stores a pointer IncidentEdge(v) to an arbitrary half-edge that has $v$ as its origin. The face record of a face $f$ stores a pointer OuterComponent(f) to some half-edge on its outer boundary. For the unbounded face this pointer is nil. It also stores a list InnerComponents(f), which contains for each hole in the face a pointer to some half-edge on the boundary of the hole. The half-edge record of a half-edge $\\overrightarrow{e}$ stores a pointer Origin($\\overrightarrow{e}$) to its origin, a pointer Twin($\\overrightarrow{e}$) to its twin half-edge, and a pointer IncidentFace($\\overrightarrow{e}$) to the face that it bounds. We don’t need to store the destination of an edge, because it is equal to Origin(Twin($\\overrightarrow{e}$)). The origin is chose such that IncidentFace($\\overrightarrow{e}$) lies to the left of $\\overrightarrow{e}$ when it is traversed from origin to destination. The half-edge record also stores pointers Next($\\overrightarrow{e}$) and Prev($\\overrightarrow{e}$) to the next and previous edge on the boundary of IncidentFace($\\overrightarrow{e}$) that has the destination of $\\overrightarrow{e}$ as its origin, and Prev($\\overrightarrow{e}$) is the unique half-edge on the boundary of IncidentFace($\\overrightarrow{e}$) that has Origin($\\overrightarrow{e}$) as its destination."
    } ,
  
    {
      "title"       : "Point Location",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Point-Location.html",
      "date"        : "2022-11-11 00:48:20 +0000",
      "description" : "Algorithms for Point Location",
      "content"     : "Point Location query Given a map and a query point $q$ specified by its coordinates, find the region of the map containing $q$. A map, of course, is nothing more than a subdivision of the plane into regions, a planar subdivision.Idea To preprocess the maps and to store them in a data structure that makes it possible to answer point location queries fast.Slab MethodLet $S$ be a planar subdivision with $n$ edges. The planar point location problem is to store $S$ in such a way that we can answer queries of the following type: ​ Given a query point $p$, report the face $f$ of $S$ that containing $q$. If $q$ lies on an edge or coincides with a vertex, the query algorithm should return this information.Method: We draw vertical lines through all vertices of the subdivision. This partitions the plane into vertical slabs. We store the $x$-coordinates of the vertices in sorted order in an array. This means it possible to determine in $O(\\log n)$ time the slab that contains a query point $q$. Within a slab, there are no vertices of $S$. We label each edge with the face $S$ that is immediately above it inside the slab. The query algorithm is: We do a binary search with the $x$-coordinate of the query point $q$ in the array storing the $x$-coordinates of the vertices of the subdivision. This tells us the slab containing $q$. Do a binary search with $q$ in the array for that slab. The elementary operation in this binary search is: Given a segment $s$ and a point $q$ such that the vertical line through $q$ intersects $s$, determine whether $q$ lies above $s$, below $s$,or on $s$. This tells us the segment directly below $q$, provided there is one. The label stored with that segment is the face of $S$ containing $q$. If we find that there is no segment below $q$ then $q$ lies in the unbounded face.The complexity: Preprocessing: slabs in a sorted list. Trapezoids within the same slab in a sorted list. Sorting in $O(n)$ slabs, each slab with $O(n)$ elements (edges it contain), takes $O(n^2\\log n)$ time. Only perform two binary searches, thence the query time is $O(\\log n)$. Storage requirement: we have an array on the $x$-coordinates of the vertices, which uses $O(n)$ storage. But we also have an array for every slab. Such an array stores the edges intersecting its slab, so it uses $O(n)$ storage. Since there are $O(n)$ slabs, the total amount of storage is $O(n^2)$.Chain MethodThe key to this method is the notion of ‘chain’ as given by the following:Definition A chain $C=(u_1,\\cdots,u_p)$ is a PSLG (planar straight-line graphs) with vertex set ${u_1,\\cdots,u_p}$ and edge set ${(u_i,u_{i+1}):i=1,\\cdots,p-1}$.Definition A chain $C=(u_1,\\cdots,u_p)$ is said to be monotone w.r.t a straight line $l$ if a line orthogonal to $l$ intersects $C$ in exactly one point.​ The operation of deciding on which side of a $p$-vertex chain $C$ a query point $z$ lies – called discrimination of $z$ against $C$, is effected in time $O(\\log p)$.Property For any two chains $C_i$ and $C_j$ of $\\mathcal{L}$, the vertices of $C_i$ which are not vertices of $C_j$ lie on the same side of $C_j$.​ $\\mathcal{L}$ is referred to as a monotone complete set of chains of $G$. Thus if there are $r$ chains in $\\mathcal{L}$ and the longest chain has $p$-vertices, then the search uses worst-case time $O(\\log p\\cdot\\log r)$.Definition Let $G$ be a PSLG with vertex set ${v_1,\\cdots,v_n}$, where the vertices are indexed from right-bottom to the upper-left. A vertex $v_j$ is said to be regular if there are integers $i&lt;j&lt;k$ such that $(v_i,v_j)$ and $(v_j,v_k)$ are edges of $G$. Graph $G$ is said to be regular if each $v_j$ is regular for $1&lt;j&lt;N$ (i.e., with the exception of the two extreme vertices $v_1$ and $v_n$).​ How we transform a non-regular graph into a regular one (to keep the monotone chain divide possible)? In the sweep, for each vertex $v$ reached we perform the following operation: locate $v$ in an interval in the status structure update the status structure if $v$ is not regular, add an edge from $v$ to the vertex associated with the interval determined in (1).Theorem An $N$-vertex PSLG can be regularized in time $N\\log N$ and space $O(N)$.Then, we find all chains for $G$ in $O(#nodes+#edges)$, as follows:The complexity: Location of a point in a regularized graph with $r$ chains and $p$ nodes per chain requires $O(\\log p\\log r)$ time. There are worst regular graphs with $n/2$ chains and $n/2$ nodes per chain. Location requires then $O(\\log n\\log n)$ time. Preprocessing requires: Regularization: $O(n\\log n)$. Monotone chains: $O(n)$. Space: $O(n^2)$.Chain Method - Reducing Space ComplexityDefine: $e_l:=$ last left-forcing edge when going down the chain tree. $e_r:=$ last right-forcing edge when going down the chain tree.3 pointers added to the each edge $e$: $F(e)$ First (topmost) chain through $e$. $L(e)$ Leftmost chain through $e$. $R(e)$ Rightmost chain through $e$.When arriving at $C_j$ where $q$ faces a hole, $C_j$ must be between $F(e_r)$ and $R(e_r)$ or between $L(e_l)$ and $F(e_l)$. In former case, go right from $C_j$, otherwise go left.Space: $O(n)$. Preprocessing and query times not affected.To reduce the time complexity:$c(u)$ original number of nodes (primary structure).$t(u)$ total number of nodes, which includes those nodes added when adding the bridges. Note that $t(u)=c(u)$ if $u$ is a leaf.Below is the analysis:\\(\\begin{align}t(u)&amp;&lt;c(u)+(t(v)+t(w))/d+2\\\\\\sum_{u}t(u)&amp;&lt;\\sum_{u}c(u)+\\frac{1}{d}(\\sum_ut(u)-t(root))+2n\\\\(1-\\frac{1}{d})\\sum_ut(u)&amp;&lt;\\sum_uc(u)+2n\\\\\\sum_ut(u)&amp;&lt;\\frac{d}{d-1}(\\sum_uc(u)+2n)\\in \\mathcal{O}(n)\\end{align}\\)where $d$ is every $d$ time. $+2$ means there are 2 topmost bridges for primary chain.Randomized Incremental AlgorithmThe first algorithm’s vertical strips idea gave a refinement of the original subdivision, but the number of faces went up from linear in $n$ to quadratic in $n$.Definition Suppose we draw vertical extensions from every vertex up and down, but only until the next line segment, Assume the input line segments are not vertical. Assume every vertex has a distinct $x$-coordinate. Assume we have a bounding box $R$ that encloses all line segments that define the subdivision.This is called the vertical decomposition or trapezoidal decomposition.Every face has a vertical left and/or right side that is a vertical extension, and is bounded from above and below by some line segment of the input. The left and right sides are defined by some endpoint of a line segment.Two trapezoids (including triangles) are neighbours if they share a vertical side. A trapezoid could have many neighbours if vertices had the same $x$-coordinate.Our structure is: Every face $\\Delta$ is an object; it has fields for top($\\Delta$), bottom($\\Delta$), leftp($\\Delta$), and rightp($\\Delta$) (two lines segments and two vertices). Every face has fields to access its up to four neighbours. Every line segment is an object and has fields for its endpoints (vertices) and the name of the face in the original subdivision directly above it. Each vertex stores its coordinates.Lemma 6.1 Each face in a trapezoidal map of a set $S$ of line segments in general position (no two distinct endpoints lie on a common vertical line) has one or two vertical sides and exactly two non-vertical sides.Lemma 6.2 The trapezoidal map $\\mathcal{T}(S)$ of a set $S$ of $n$ line segments in general position contains at most $6n+4$ vertices and at most $3n+1$ trapezoids.Proof A vertex of $\\mathcal{T}(S)$ is either: A vertex of $R$, where $R$ is the outer rectangular. An endpoint of a segment in $S$, or else The point where the vertical extension starting in an endpoint abuts on another segment or an the boundary of $R$. Every endpoint of a segment induces two vertical extensions – one upward and one downward. ($2n$ points and 2 lines up&amp;down)In total $4+2n+2(2n)=6n+4$.For bound of trapezoids number: here we give a direct proof, using the point leftp(∆). the lower left corner of $R$ plays this role for exactly one trapezoid, (1) a right endpoint of a segment can play this role for at most one trapezoid, ($n$) a left endpoint of a segment can be the leftp(∆) of at most two different trapezoids. ($2n$)In total: $1+n+2n=3n+1$.We will use randomized incremental construction to build, for a set $S$ of non-crossing line segments: A vertical decomposition $T$ of $S$ and $R$ A search structure $D$ whose leaves correspond to the trapezoids of $T$Start with $R$, then add the line segments in random order and maintain $T$ and $D$.Let $s_1,\\cdots, s_n$ be the $n$ line segments in random order. Let $T_i$ be the vertical decomposition of $R$ and $s_1,\\cdots,s_i$, and let $D_i$ be the search structure obtained by inserting $s_1,\\cdots,s_i$ in this order.We want only one leaf in $D$ to correspond to each trapezoid; this means we get a directed acyclic graph (DAG) (one leaf could only have one father node) instead of a search tree (one father per son). Right is the the point location query.The incremental step:Suppose we have $D_{i-1}$ and $T_{i-1}$, how do we add $s_i$?Because $D_{i-1}$ is a valid point location structure for $s_1,\\cdots,s_{i-1}$, we can use it to find the trapezoid of $T_{i-1}$ that contains $p_i$, the left endpoint of $s_i$ (query process). Then we use $T_{i-1}$ to find all other trapezoids that intersect $s_i$, because every face stores the information of its neighbour. After locating the trapezoid that contains $p_i$, we can determine all $k$ trapezoids that intersect $s_i$ in $O(k)$ time by traversing $T_{i-1}$. The update of the vertical decomposition can be finished in $O(k)$ as well. More specifically: If line segment $s_i$ is completely contained in a trapezoid $\\Delta=\\Delta_0$, then we can update as follows: To update $T$, we delete ∆ from $T$, and replace it by four new trapezoids $A,B,C,$ and $D$. To update $D$, what we must do is replace the leaf for $\\Delta$ by a little tree with four leaves. If $s_i$ intersects $k_i$ trapezoid: To update $T$, we first erect vertical extensions through the endpoints of $s_i$ and re-index them, $O(k_i)$. To update $D$, If $\\Delta_0$ has the left endpoint of $s_i$ in its interior (which means it has been partitioned into three new trapezoids) then were place the leaf for $\\Delta_0$ with an $x$-node for the left endpoint of $s_i$ and a $y$-node for the segment $s_i$. Similarly, if $\\Delta_k$ has the right endpoint of $s_i$ in its interior, were place the leaf for $\\Delta_k$ with an $x$-node for the right endpoint of $s_i$ and a $y$-node for $s_i$. Finally, the leaves of $\\Delta_1$ to $\\Delta_{k-1}$are replaced with single $y$-nodes for the segment $s_i$. (Update by replacing $k_i$ leaves by $O(k_i)$ new internal nodes and $O(k_i)$ new leaves.) The maximum depth increase is three nodes. Space and Time analysisFor any trapezoid $\\Delta$, there are at most $4$ line segments whose insertion would have created it (top($\\Delta$), bottom($\\Delta$), leftp($\\Delta$), rightp($\\Delta$)).SpaceLet $n_i$ be # of “new” trapezoids of $T_i$, i.e., the ones that are not trapezoids of $T_{i-1}$. Then we have:\\(|D_i|-|D_{i-1}|=O(n_i)\\)Here we have $n_i=\\Theta(k_i)$, where $k_i$ is the # of trapezoids of $T_{i-1}$ intersected by $s_i$.$T_i$ has $\\leq 3i+1$ trapezoids and when we add line $s_i$, each trapezoid has probability $\\leq 4/i$ of being new, where $i$ is remaining # of line segments. Hence,\\(\\mathbb{E}[n_i]\\leq(3i+1)\\cdot4/i\\leq 13\\)Therefore,\\(\\mathbb{E}[|D_n|]=\\mathbb{E}[O(\\sum_{i=1}^n n_i)]=O(\\sum_{i=1}^n\\mathbb{E}[n_i])=O(13n)=O(n)\\)Query TimeDefine $X_i=1$ if the search path for any query point $p$ increases in iteration $i$. Otherwise, $X_i=0$. In other words, $X_i=1$ if and only if trapezoid containing $p$ in $T_i$ is new.\\(\\mathbb{E}[\\sum_{i=1}^nX_i]=\\sum_{i=1}^n\\mathbb{E}[X_i]=\\sum_{i=1}^n\\mathbb{P}[X_i=1]\\)Hence, $P[X_i=1]\\leq 4/i$, since at most $4$ of the $i$ segments in $T_i$ could have caused the trapezoid containing $p$ to be new (just created). \\(\\mathbb{E}[\\sum_{i=1}^nX_i]=\\sum_{i=1}^n\\mathbb{P}[X_i=1]\\leq\\sum_{i=1}^n 4/i=O(\\log n)\\)The search path increases by at most $3$ at a time, so the final search is $O(\\log n)$.Theorem Given a planar subdivision defined by a set of $n$ non-crossing line segments in the plane, we can preprocess it for planar point location queries in $O(n\\log n)$ expected time, the structure uses $O(n)$ expected storage, and the expected query time is $O(\\log n)$."
    } ,
  
    {
      "title"       : "Orthogonal Range Searching",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Orthogonal-Range-Search.html",
      "date"        : "2022-11-11 00:48:20 +0000",
      "description" : "Algorithms for Orthogonal Range Searching",
      "content"     : "Definition A query asking to report all records whose fields lie between specified values, then transforms to a query asking for all points inside a $d$-dimensional axis-parallel box. Such a query is called a rectangular range query, or an orthogonal range query in CG.Normalization $x$- and $y$-coordinates of points can be replaced by integers $1,2,3,\\cdots, n$ in $O(n\\log n)$ time (First sort and re-index). When querying, the coordinates of of the rectangle corners can be transformed to appropriate integers in $O(\\log n)$ time.In the remainder of this section we assume that no two pints in $P$ have the same $x$-coordinate, and no two points have the same $y$-coordinate.Kd-TreesBasic DefinitionA Kd-Tree looks like:Every vertical/horizontal line split current graph into two parts each with equal number of points on both sides until each partition contains only one point. Each node in Kd-tree represents a line. The nodes in even length from root represent the vertical line and others on odd length represent the odd line.Preprocessing TimeThe most expensive step is performed at every recursive call is finding the splitting line. This requires determining the median $x$-coordinate or the median $y$-coordinate, depending on whether the depth is even or odd. We find the median in linear time relative simply in such way, sort by $x$- and $y$- coordinates independently. Hence, the building time $T(n)$ satisfies the recurrence:\\(T_n=\\begin{cases}O(1), &amp; if\\quad n=1\\\\O(n)+2T(\\lceil n/2\\rceil), &amp; if \\quad n&gt;1\\end{cases}\\)which solves to $O(n\\log n)$. Here $O(n)$ is the expense for median finding and recursive expression $T(\\lceil n/2\\rceil)$ shows the left and right build procedure.Space: Binary tree with $n$ leaves. $O(n)$ space.Lemma A Kd-tree for a set of $n$ points uses $O(n)$ storage and can be constructed in $O(n\\log n)$ time.Query TimeThe region of a node $v$, denoted as $region(v)$, in Kd-Tree is:Such a $region(v)$ is formed by the line represented by the ancestor nodes of $v$.The query algorithm is: we traverse the Kd-Tree, but visit only nodes whose region is interested by the query rectangle. When a region is fully contained in the query rectangle, we can report all the points stored in its subtree. When the traversal reaches a leaf, we have to check whether the points stored at the leaf is contained in the query region and, if so, report it.The main test of the query algorithm performs is whether the query range $R$ intersects the region corresponding to some node $v$. One can maintain the current region through the recursive calls using the lines stored in the internal nodes. For instance, the region corresponding to the left child of a node $ν$ at even depth can be computed from $region(ν)$ as follows:\\(\\operatorname{region}(l c(v))=\\operatorname{region}(v) \\cap \\ell(v)^{\\text {left }}\\)where $\\ell(v)$ is the splitting line stored at $v$, and $\\ell(v)^{left}$ is the half-plane to the left of and including $\\ell(v)$.The time we need to traverse a subtree and report the points stored in its leaves is linear in the number of reported points, which is $O(k)$. Besides, it remains to bound the number of nodes visited by the query algorithm that are not in one of the traversed subtrees. To analyze the number of such nodes, we shall bound the number of regions interested by any vertical line.Let $\\ell$ be a vertical line, and let $\\mathcal{T}$ be a Kd-Tree. Let $\\ell(root(\\mathcal{T}))$ be the splitting line stored at the root of the Kd-Tree. Observe that if the line $\\ell$ intersects, for instance $region(lc(root(\\mathcal{T})))$, then it will always intersect the regions corresponding to both children of $lc(root(\\mathcal{T}))$.Define $Q(n)$ as the number of interested regions in a Kd-Tree storing $n$ points whose root contains a vertical splitting line. To write recurrence for $Q(n)$ we have to go down two steps in the tree. Each of the four nodes at depth two in the tree corresponds to a region containing $n/4$ points.Two of the four nodes correspond to intersected regions (at least two regions would be interested by such region), so we have to count the number of intersected regions of the remaining 2 nodes ($Q(n/4)+Q(n/4)$) in these subtrees recursively. Hence, $Q(n)$ satisfies the recurrence\\(Q(n)=\\begin{cases}O(1), &amp;if \\quad n=1\\\\2 + 2Q(n/4), &amp;if \\quad n&gt;1\\end{cases}\\)This recurrence solves to $Q(n)=O(\\sqrt{n})$. In other words, any vertical line intersects $O(\\sqrt{n})$ regions in a Kd-Tree.Theorem A Kd-Tree for a set $P$ of $n$ points in the plane use $O(n)$ storage and can be built in $O(n\\log n)$ time. A rectangular range query on the Kd-Tree takes $O(\\sqrt n+k)$ time, where $k$ is the number of reported points. If its $d$-dimensional, the query time is bounded by $O(n^{1-1/d}+k)$.1-Dimensional Range SearchAbove data structure is a BST and we call it Threaded Binary Tree .For a 1-dimensional range query, $[u,u’]$, we first binary search $u$ in the tree, for each node $v$, report nodes in $rc(v)$ . Then search $u’$ and report all nodes in $lc(v)$.Theorem Let $P$ be a set of $n$ points in 1-dimensional space. The set $P$ can be stored in a balanced BST, which uses $O(n)$ storage and has $O(n\\log n)$ construction time, such that the points in a query range can be reported in time $O(k+\\log n)$, where $k$ is the number of reported points.Range TreeThe range tree is: The main tree $\\mathcal{T}$ is a balanced binary search tree built on the $x$-coordinate of the points in $P$. For any internal or leaf node $v\\in \\mathcal{T}$, the canonical subset $P(v)$, which is the subset of points store in the leaves of the subtree rooted at a node $v$, is stored in a balanced associated BST $\\mathcal{T}(v)$ on the $y$-coordinate of the points. The node $v$ stores a pointer to the root of $\\mathcal{T}(v)$, which is called the associated structure of $v$.Space Because 1-dimensional range trees use linear storage it follows that the associated structures of all nodes at any depth of $\\mathcal{T}$ together use $O(n)$ storage. The depth of $\\mathcal{T}$ is $O(\\log n)$. Hence, the total amount of storage required is bounded by $O(n\\log n)$.Preconstruct Constructing a BST from an unordered list is $O(n\\log n)$ but if the list is sorted, it could be reduced to $O(n)$. Thus, for this two level structure, we first sort the $x$-coordinate and $y$-coordinate and then we build the first level-tree and second level tree in $O(n)$, totally $O(n\\log n)$.Query First selects $O(\\log n)$ canonical subsets that together contain the points whose $x$-coordinate lie in the range $[x,x’]$, This can be done with the 1-dimensional query algorithm. Of those subsets, we then report the points whose $y$-coordinate lie in the range $[y,y’]$ using same methods. Thus in total $O(\\log^2n+k)$.Theorem Let $P$ be a set of $n$ points in the $d$-dimension. A range tree for $P$ uses $O(n(\\log n)^{d-1})$ storage and can be constructed in $O(n(\\log n)^{d-1})$ time. By querying this range tree one can report the points in $P$ that lie in a rectangular query range in $O(\\log^dn+k)$ time, where $k$ is the number of reported points.Improved Range TreeFractional Cascading​ Let $S_1$ and $S_2$ be two sorted lists of numbers. Generally, if we want to report all objects in $S_1$ and $S_2$ whose keys lie in a query interval $[y,y’]$, we need to do two binary searches with $y$ in $S$ and and walk along $S$ until $y’$. The total time is $O(k)$ plus the time for two binary searches, one in $S_1$ and the other in $S_2$.​ If, however, the keys of the objects in $S_2$ are a subset of the keys of the objects in $S_1$, then we can avoid the second binary search as follows. We add pointers from the entries in $S_1$ to the entries in $S_2$: if $S_1[i]$ stores an object with key $y_i$, then we store a pointer to the entry in $S_2$ with the smallest key larger than or equal to $y_i$. If there is no such key, then the pointer from $S_1[i]$ is $nil$. Then in the search of $S_2$, we just follow the pointer created in process of $S_1$, which takes only $O(1+k)$ time.Range Tree has exactly such structure. We use Fractional Cascading to improve it.After sorted in preprocessing, The second-level structure is always the subset of its ancestor nodes. Since we find the same nodes, in the first level binary search we can position the node we should start search in second level. For example, in root node, we find 2 as the left most point, and the pointer in 2 points to 6 since we have sorted it in $y$-monotone already.Theorem Let $P$ be a set of $n$ points in $d$-dimensional space, with $d\\geq 2$. A layered range tree for $P$ uses $O(n\\log^{d-1}n)$ storage and it can be constructed in $O(n\\log^{d-1}n)$ time. With this range tree one can report the points in $P$ lie in a rectangular query range in $O(\\log^{d-1}n+k)$ time, where $k$ is the number of reported points.Reference: Orthogonal Range Search, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Polygon Triangulation",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Polygon-Triangulation.html",
      "date"        : "2022-11-10 02:48:20 +0000",
      "description" : "Algorithms for polygon triangulation",
      "content"     : "Art gallery problemTwo points in a simple polygon can see each other if their connecting line segment is in the polygon.Definition The art gallery problem:​ How many points are needed in a simple polygon with $n$ vertices so that every point in the polygon is seen?This problem is NP-hard.Theorem art gallery theorem:​ $\\lfloor n/3\\rfloor$ cameras are occasionally necessary but always sufficient.Some Definition Polygon $P$ is triangulated: a decomposition of $P$ into disjoint triangles by a maximal set of non-intersecting diagonals. Diagonal of $P$: open line segment that connects two vertices of $P$ and fully lies in the interior of $P$. Dual graph for a plane graph $G$ is a graph which is, each face in primal graph gives a node; two nodes are connected in dual graph if the faces are adjacent. The dual graph of a triangulated simple polygon without hole is a tree. A simple polygon is y-monotone iff any horizontal line intersects it in a connected set (or not at all), or equivalently, if every horizontal line intersects it at most twice.Lemma: A simple polygon with $n$ vertices can always be triangulated, and always into $n-2$ triangles.Proof Every tree has a leaf, in particular the one that is the dual graph. Remove the corresponding triangle from the triangulated polygon, colour its vertices, add the triangle back, and let the extra vertex have the colour different from its neighbours.For a 3-coloured, triangulated simple, one of the color classes is used by at most $\\lfloor n/3\\rfloor$ colors. Place the cameras at these vertices.Triangulate a polygonOverview: Use plane sweep to partition the polygon into $y$-monotone polygons. Triangulate each $y$-monotone polygon.Partition into monotone piecesVertex type: Start, above space of the vertex does not belongs to the polygon, Stop/End, below space of the vertex does not belongs to the polygon, Split, the polygon separate into two parts after this point, Merge, the polygon merge into one part after this point, Regular.The sweep idea is, find diagonals from each merge vertex down, and from each split vertex up. Since these two kinds of points change the monotone of the polygon.Definition The helper for an edge $e$ that has the polygon right of it, and a position of the sweep line, is the lowest vertex $v$ above the sweep line such that the horizontal line segment connecting $e$ and $v$ is inside the polygon.Definition The status is the set of edges intersecting the sweep line that have the polygon to their right, sorted from left to right, and each with their helper: the last vertex passed in that component. The status structure stores all edges that have the polygon to the right, with their helper, sorted from left to right in the leaves of a balanced binary search tree $T$.The event happen only at the vertices: sort them by $y$-coordinate and put them in a list.Now we begin sweep the initial polygon and prepare to handle the different event when the sweep line meets the vertex of: Start vertex $v$: insert the ccw incident edge in $T$ with $v$ as the helper (the left edge behind $v$). End vertex $v$: delete the clockwise incident edge and its helper from $T$ (the left edge above $v$). Regular vertex $v$: if the polygon is right of the two incident edges, then replace the upper edge by the lower edge in $T$, and make $v$ the helper. If the polygon is left of the two incident edges, then find the edge $e$ directly left of $v$, and replace its helper by $v$. Merge vertex $v$: Remove the edge clockwise from $v$ from $T$. Find the edge $e$ directly left of $v$, and replace its helper by $v$. Split vertex $v$: Find the edge $e$ directly left of $v$, and choose as a diagonal the edge between its helper and $v$. Replace the helper of $e$ by $v$. Insert the edge ccw from $v$ in $T$, with $v$ as its helper.Efficiency:​ Sorting all events by $y$-coordinate takes $O(n\\log n)$ time. Every event takes $O(\\log n)$ time, because it only involves querying, inserting and deleting in $T$.Two-direction Sweep:​ We need to sweep in both upward and downward direction, since unidirectional sweep is insufficient divide the polygon into monotone spices. For a same vertex, maximum 2 diagonals would be chosen to the same vertex. Because, if $u$ is a split vertex, an edge is added to $u$ and the helper of $u$; then the sweep continuous, another split vertex below which regards $u$ as its helper would also add one edge to $u$, then $u$ would never become helper.Theorem: A simple polygon with $n$ vertices can be partitioned into $y$-monotone pieces in $O(n\\log n)$ time.Triangulating a monotone polygonThe algorithm: Sort the vertices top-to-bottom by a merge of the two chains, Initialize a stack. Push the first two vertices, Take the next vertex $v$, and triangulate as much as possible, top-down, while popping the stack, Push $v$ onto the stack.Theorem A monotone polygon with $n$ vertices can be triangulated $O(n)$ time.Triangulating a simple polygonWe need to argue that all $y$-monotone polygons together that we will triangulate have $O(n)$ vertices. Initially we had $n$ edges. We add at most $n-3$ diagonals in the sweeps. These diagonals are used on both sides as edges. So all monotone polygons together have at most $n+2(n-3)=3n-6$ edges, and therefore at most $3n-6$ vertices. Note that the complexity all about the total computation load, hence we can conclude that triangulating all monotone polygons together takes only $O(n)$ time.Theorem A simple polygon with $n$ vertices can be triangulated $O(n\\log n)$ time.Reference: Polygon Triangulation, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } ,
  
    {
      "title"       : "Convex Hull",
      "category"    : "",
      "tags"        : "Computational Geometry",
      "url"         : "./Convex-Hull.html",
      "date"        : "2022-11-09 04:48:20 +0000",
      "description" : "Algorithms for computing a Convex Hull",
      "content"     : "Problem DefinitionGiven: A set $Z$ of $n$ points in the plane.Find: Smallest convex set containing $Z$.Some Basic Definition A set $S$ in the plane is convex iff for every pair of points $p_1$ and $p_2$ in $S$, the line-segment $p_1p_2 $ is in $S$. A point $p$ in a convex set $S$ is said to be extreme (or a corner) iff no segment $ab$ in $S$ has $p$ in its interior. $CH(Z)$ is considered to be determined once its corners ordered around the boundary are found. Simplifying assumptions: No pair of Z-points has the same x- or y-coordinate and/or no three points colinear.Equivalent Formulations for CH Intersection of all convex sets containing $Z$. Intersection of all half-planes containing $Z$. Smallest possible convex set containing $Z$. Convex set with the smallest possible perimeter and containing $Z$.Sorting can be transformed in $O(n)$ time into the convex hull problem. Thus the lower bound of the complexity of CH is same as sorting which is $O(n\\log n)$.Point $p_1,p_2,p_3$ make a right turn at $p_2$ iff $p_3$ is to the right or on the line through $p_1$ and $p_2$. Otherwise $p_1,p_2,p_3$ make a left turn at $p_2$. Mathematically speaking, if:\\(det\\begin{bmatrix}x_1 &amp; y_1 &amp; 1\\\\x_2 &amp; y_2 &amp; 1\\\\x_3 &amp; y_3 &amp; 1\\end{bmatrix}&gt;0 \\Rightarrow \\textit{left turn}\\)Algorithm 1: Point PruningSince: A point in set $Z$ which is not a corner is inside a triangle on $Z$. Use $O(n^3)$ time to enumerate the triangles and for every triangles use $O(n)$ transverse other point to check whether it is contained. When whole procedure finishes, the remaining points never included are corners. Actually, we can select the left/up and right/down extreme points to form a bottom edge for triangle and enumerate the third vertex and check the other $Z$-point inclusion in $O(n\\cdot n)$, cuz that the two extreme points must be included in corners. Then, we need to sort the corners. Take any point in $CH(Z)$ and sort corners around it. Draw line through the leftmost and rightmost corners. Sort corners above the line by increasing x-coordinate and sort corners below the line by decreasing x-coordinate. All this can be done in $O(n\\log n)$ time. Algorithm 2: Edge Pruning → Jarvis March (1973)Naïve approach: Arbitrarily pick one edge $O(n^2)$ and check whether all other points are located on same side of edge (left/right turn, $O(n)$ ). In total $O(n^3)$. Sorting of corners remains.Jarvis’s March: When a boundary edge $z_iz_j$ has been identified, there must exist another boundary edge with $z_j$ as one of its endpoints. Boundary edge can be founded by starting from extreme point. Find boundary edge consecutively. Corner sorting still needed. $O(nh)$, where $h$ is the number of corners. Expected number of corners of points independently and uniformly distributed within a unit circle is $O(n^{1/3})$.Algorithm 3: Graham’s Scan (1972)Procedure: Sort points around some point of CH(Z). Points at the same angle are sorted by their distance. Construct the polygon defined by the sorting. Prune the nodes. If we transverse the nodes in counterclockwise (ccw) order, all middle nodes should make a left turn for pairs $p+,p,p-$, otherwise it can be removed. After remove the middle point $p$, $p-$ would go backward, otherwise all three points walk forward. Algorithm terminate when the initial corner arrived by a forward step.Something may goes wrong: Will never go backwards behind the initial corner, which means if we select a wrong initial corner at first, it would be dropped and we will never trace back to it.Complexity: # of backward steps is $O(n)$. # of forward step is $O(n)$. Sorting $O(n\\log n)$. Totally, $O(n\\log n)$.Algorithm 4: Divide and ConquerPartition $Z$ into balanced subsets $Z_1$ and $Z_2$, determine $CH(Z_1)$ and $CH(Z_2)$ recursively. The problem solve directly if $n\\leq 2$.Merge: For each merge phase, two sub-polygon with corners sorted are available. Then select one point arbitrarily, say point 1. Build two sorted edge set between point 1 and other points. If point 1 is inside another polygon, cause this two edges are all sorted, we can merge them directly. If point 2 is outside another polygon, we pick two extreme points (which is exterior most to point 2), say point 3 and point 4. For all other points $q$, we check whether it make a left turn from point 3 to point 2, or form a right turn from point 4 to point 2. If not, we drop this point. (or we can check whether this point is included by the other polygon)Partition and union complexity:\\(\\begin{array}{c}T(n)=O(1), n \\leq 2 \\\\T(n)=2 * T(n / 2)+O(n), n&gt;2\\end{array}\\)Overall $O(n\\log n)$.Algorithm 5: Marriage-before-Conquest (1986)“Reverse Order” than Divide-and-Conquer.Calculate the Upper and Lower Convex Hulls separately and merge them. Divide the nodes into 2 points, which is approximately same. Find the Bridge across two sides. Drop the nodes exactly below the bridge and compute the left upper CH and right upper CH recursively. Merge.How to find a Bridge? Build edges by pairing two nodes arbitrarily. Select the edge $e$ with median slope. Move $e$ parallelly to the upper/lower extreme point $p$ (no more higher /lower nodes exists). If exactly two nodes from both sides located in same line, the line is bridge and then be returned. Otherwise, for all of other points $p_i$ in same side of $p$, calculate the slope $e_i=(p,p_i)$ . If $p$ is on left side and $e_i&gt;e$, drop $p_i$, or if $p$ is on right side and $e_i&lt;e$, drop $p_i$. Repeat until only 1 node in opposite side of $p$ exists.Complexity containing both Bridge Finding, and Overall Complexity is shown as follows, big constant.Algorithm 6: Chan’sAlgorithms with complexity measured as a function of both $n$ and output size $h$ are said to be output-sensitive.Let $P\\subset E^2$ be a set of $n\\geq 3$ points. The procedure of Chan’s algorithm is:Algorithm Hull2D($P, m, H$), where $P \\subset E^2$, $3 ≤ m ≤ n$, and $H ≥ 1$ partition $P$ into subsets $P_1,\\cdots,P_{\\lceil n/m\\rceil}$ each of size at most $m$ for $i=1,\\cdots, \\lceil n/m\\rceil$ do compute conv($P_i$) by Graham’s scan and store its vertices in an array in ccw order $p_0\\leftarrow (0,-\\infty)$ $p_1\\leftarrow$ the rightmost point of $P$ for $k=1,\\cdots,H$ do for $i=1,\\cdots,\\lceil n/m\\rceil$ do compute the points $q_i\\in P_i$ that maximizes $\\angle p_{k-1}p_kq_i\\quad (q_i\\neq p_k)$ by performing a binary search on the vertices of conv($P_i$) $p_{k+1}\\rightarrow$ the point $q$ from ${q_1,\\cdots,q_{\\lceil n/m\\rceil}}$ that maximizes $\\angle p_{k-1}p_kq$ if $p_{k+1}=p_1$ then return the list $\\langle p_1,\\cdots,p_k\\rangle$ return incompleteBy choosing $m = H$, the complexity of the algorithm is then $O(n(1+H/m) \\log m) = O(n \\log H)$. Since the value of $h$ is not known in advance, we use a sequence of $H$’s to “guess” its value as shown below:Algorithm Hull2D($P$), where $P \\subset E^2$ for $t = 1, 2,\\cdots $ do $L\\rightarrow $ Hull2D($P,m,H$), where $m=H=\\min{2^{2^t},n}$ if $L\\neq incomplete$ then return $L$ The procedure stops with the list of hull vertices as soon as the value of $H$ in the for-loop reaches or exceeds $h$. The number of iterations in the loop is $\\lceil \\log \\log h\\rceil$ (using base-2 logarithms), and the $t$-th iteration takes $O(n \\log H) = O(n2^t )$ time. Therefore, the total running time of the algorithm is $O(\\sum_{t=1}^{\\lceil \\log\\log h\\rceil}n2^t)=O(n2^{\\lceil\\log\\log h\\rceil+1})=O(n\\log h)$. The storage requirement is clearly linear.Reference: Convex Hull, CG - Lecture, UCPH-DIKU. Chan’s paper"
    } 
  
]
